<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Agent System Visualizer - Anthropic Architecture</title>
    
    <!-- Three.js CDN with fallback -->
    <script>
        // Check if Three.js loads properly
        window.threeJSLoaded = false;
        window.threeJSLoadError = false;
        
        function loadThreeJS() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
                script.onload = () => {
                    window.threeJSLoaded = true;
                    resolve();
                };
                script.onerror = () => {
                    window.threeJSLoadError = true;
                    reject(new Error('Failed to load Three.js'));
                };
                document.head.appendChild(script);
            });
        }
        
        function loadOrbitControls() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
    </script>
    
    <!-- Socket.io CDN -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
            cursor: crosshair;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #header {
            position: absolute;
            top: 25px;
            left: 25px;
            background: rgba(0, 0, 0, 0.6);
            padding: 22px 26px;
            border-radius: 16px;
            pointer-events: auto;
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            width: 300px;
        }

        #header h1 {
            color: #ffffff;
            font-size: 22px;
            margin-bottom: 8px;
            font-weight: 400;
            letter-spacing: 0.5px;
            line-height: 1.2;
        }

        #header p {
            color: #666;
            font-size: 11px;
            margin-bottom: 3px;
        }

        #header .tech-stack {
            color: #b0b0b0;
            font-size: 11px;
            font-weight: 300;
            margin-top: 8px;
            margin-bottom: 10px;
            letter-spacing: 0.3px;
        }
        
        #header .architecture-info {
            color: #00ffff;
            font-size: 11px;
            margin-bottom: 8px 
            line-height: 1.3;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
        }
         
        #header .architecture-info a {
            color: #00ffff;
            text-decoration: none;
            transition: all 0.3s ease;
        }
        
        #header .architecture-info a:hover {
            color: #ffffff;
            text-shadow: 0 0 12px rgba(0, 255, 255, 0.8);
        }

        #research-panel {
            position: absolute;
            bottom: 25px;
            left: 25px;
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 12px;
            pointer-events: auto;
            backdrop-filter: blur(15px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            width: 280px;
        }

        #research-panel h3 {
            color: #ffffff;
            font-size: 10px;
            margin-bottom: 10px;
            font-weight: 400;
            letter-spacing: 0.5px;
            opacity: 0.6;
        }

        .research-input-container {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .research-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            padding: 8px 12px;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            outline: none;
            transition: all 0.3s ease;
        }

        .research-input:focus {
            border-color: #ffffff;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        .research-button {
            background: #ffffff;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            color: #000;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
            min-width: 40px;
            font-weight: 500;
        }

        .research-button:hover {
            background: #f0f0f0;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.3);
        }

        .research-status {
            font-size: 11px;
            line-height: 1.4;
        }
        
        .research-controls {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 10px;
        }
        
        .clear-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 6px 12px;
            color: #fff;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
            font-family: 'Courier New', monospace;
        }
        
        .clear-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
        }

        #loading h2 {
            color: #00ff88;
            font-size: 24px;
            margin-bottom: 20px;
            font-weight: 400;
            letter-spacing: 1px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #00ff88;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 0, 0, 0.1);
            padding: 30px;
            border-radius: 16px;
            border: 1px solid rgba(255, 0, 0, 0.3);
            display: none;
            z-index: 100;
        }

        #error-message h3 {
            color: #ff6b6b;
            margin-bottom: 15px;
        }

        #error-message p {
            color: #ccc;
            font-size: 14px;
        }

        #tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 320px;
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.6);
            display: none;
        }

        .fadeInUp {
            animation: fadeInUp 0.3s ease;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="ui">
            <div id="header">
                <h1>Multi-Agent System Visualizer</h1>
                <p>Powered by Astro + LangGraph</p>
                <div class="architecture-info">
                    <a href="#" onclick="showArchitectureInfo()">ANTHROPIC ARCHITECTURE</a>
                </div>
                <div class="architecture-info">
                    <a href="https://github.com/abdulmalikds" target="_blank">@ABDULMALIKDS</a>
                </div>
            </div>

            <div id="research-panel">
                <h3>Research</h3>
                <div class="research-input-container">
                    <input type="text" id="researchTopic" placeholder="Enter research topic..." class="research-input">
                    <button onclick="startUserResearch()" class="research-button">Search</button>
                </div>
                <div class="research-controls">
                    <button onclick="clearResearchVisualizations()" class="clear-button">Clear</button>
                </div>
                <div class="research-status" id="researchStatus"></div>
            </div>
        </div>
        
        <div id="loading">
            <h2>Initializing Research Network...</h2>
            <div class="spinner"></div>
        </div>

        <div id="error-message">
            <h3>Loading Error</h3>
            <p>Failed to load Three.js library. Please refresh the page.</p>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let agents = new Map();
        let connections = [];
        let dataFlowParticles = [];
        let socket;
        let animationId;
        let lastTime = 0;
        
        // Vector space visualization
        let vectorScene, vectorCamera, vectorRenderer;
        let vectorPoints = [];
        let vectorConnections = [];
        let vectorParticles = [];
        let embeddings = [];

        // Smart Hover State Management System
        let hoverState = {
            currentAgent: null,
            tooltipVisible: false,
            hoverTimeout: null,
            lastHoverTime: 0
        };

        // Enhanced tooltip hiding with better responsiveness
        let tooltipHideTimeout = null;
        
        function hideTooltipWithDelay() {
            if (tooltipHideTimeout) {
                clearTimeout(tooltipHideTimeout);
            }
            tooltipHideTimeout = setTimeout(() => {
                hideTooltip();
                hoverState.tooltipVisible = false;
                hoverState.currentAgent = null;
            }, 150);
        }

        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }

        // Minimal debug logging to reduce console popups
        function debugLog(message, type = 'info') {
            // Only log critical errors to reduce popup messages
            if (type === 'error') {
                console.error(`[ERROR] ${message}`);
            }
            // Silently ignore other log types to reduce console noise
        }

        // Check if Three.js is loaded
        function checkThreeJS() {
            if (typeof THREE === 'undefined') {
                debugLog('Three.js not loaded, showing error message', 'error');
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error-message').style.display = 'block';
                return false;
            }
            
            if (typeof THREE.OrbitControls === 'undefined') {
                debugLog('OrbitControls not loaded, but Three.js is available', 'warning');
            }
            
            return true;
        }

        // Initialize the application
        async function init() {
            try {
                // Load Three.js if not already loaded
                if (typeof THREE === 'undefined') {
                    await loadThreeJS();
                }
                
                if (typeof THREE.OrbitControls === 'undefined') {
                    await loadOrbitControls();
                }
                
                // Hide loading screen
                const loadingScreen = document.getElementById('loading');
                if (loadingScreen) {
                    loadingScreen.style.display = 'none';
                }
                
                if (!checkThreeJS()) {
                    return;
                }
                
                // Initialize Three.js components
                initThreeJS();
                
                // Initialize vector space visualization
                initVectorSpace();
                
                // Initialize WebSocket connection
                initWebSocket();
                
                // Start animation loop
                animate();
                
                // Add event listeners
                addEventListeners();
                
                debugLog('Application initialized successfully', 'info');
                
            } catch (error) {
                debugLog(`Initialization error: ${error.message}`, 'error');
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error-message').style.display = 'block';
            }
        }

        // Initialize Three.js components
        function initThreeJS() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Controls setup
            if (typeof THREE.OrbitControls !== 'undefined') {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
            }
            
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // Create initial agents
            createInitialAgents();
        }

        // Create initial agents
        function createInitialAgents() {
            const agentData = [
                { name: 'LeadResearcher', role: 'Research Orchestrator', color: 0x00ff88, position: [-3, 0, 0] },
                { name: 'WebSearch Agent', role: 'Information Gatherer', color: 0x0088ff, position: [3, 0, 0] },
                { name: 'Analysis Agent', role: 'Pattern Analyzer', color: 0xff8800, position: [0, 0, 3] },
                { name: 'Citation Agent', role: 'Source Validator', color: 0xff0088, position: [0, 0, -3] }
            ];
            
            agentData.forEach((data, index) => {
                createAgent(data, index);
            });
            
            // Create connections between agents
            createConnections();
        }

        // Create a single agent
        function createAgent(data, index) {
            const geometry = new THREE.SphereGeometry(0.5, 32, 32);
            const material = new THREE.MeshPhongMaterial({ 
                color: data.color,
                emissive: data.color,
                emissiveIntensity: 0.2,
                transparent: true,
                opacity: 0.9
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(...data.position);
            mesh.userData = {
                name: data.name,
                role: data.role,
                color: data.color,
                agentId: `agent_${index}`,
                state: 'idle',
                currentTask: 'Standby',
                taskProgress: 0,
                lastInteraction: Date.now()
            };
            
            // Add glow effect
            const glowGeometry = new THREE.SphereGeometry(0.7, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: data.color,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(mesh.position);
            
            // Add neural overlay
            const neuralGeometry = new THREE.SphereGeometry(0.6, 16, 16);
            const neuralMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                wireframe: true,
                transparent: true,
                opacity: 0.2
            });
            const neuralOverlay = new THREE.Mesh(neuralGeometry, neuralMaterial);
            neuralOverlay.position.copy(mesh.position);
            
            scene.add(mesh);
            scene.add(glow);
            scene.add(neuralOverlay);
            
            agents.set(`agent_${index}`, {
                mesh: mesh,
                glow: glow,
                neuralOverlay: neuralOverlay,
                originalPosition: mesh.position.clone(),
                data: data
            });
        }

        // Create connections between agents
        function createConnections() {
            const agentKeys = Array.from(agents.keys());
            
            for (let i = 0; i < agentKeys.length; i++) {
                for (let j = i + 1; j < agentKeys.length; j++) {
                    const agent1 = agents.get(agentKeys[i]);
                    const agent2 = agents.get(agentKeys[j]);
                    
                    if (agent1 && agent2) {
                        const points = [
                            agent1.mesh.position.clone(),
                            agent2.mesh.position.clone()
                        ];
                        
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const material = new THREE.LineBasicMaterial({
                            color: 0x00ff88,
                            transparent: true,
                            opacity: 0.4
                        });
                        
                        const line = new THREE.Line(geometry, material);
                        line.userData = {
                            agent1: agent1.mesh,
                            agent2: agent2.mesh
                        };
                        
                        scene.add(line);
                        connections.push(line);
                    }
                }
            }
        }

        // Initialize WebSocket connection
        function initWebSocket() {
            try {
                socket = io('http://localhost:3000');
                
                socket.on('connect', () => {
                    debugLog('Connected to server', 'info');
                });
                
                socket.on('disconnect', () => {
                    debugLog('Disconnected from server', 'warning');
                });
                
                socket.on('agentUpdate', (data) => {
                    updateAgent(data);
                });
                
                socket.on('researchComplete', (data) => {
                    handleResearchComplete(data);
                });
                
            } catch (error) {
                debugLog(`WebSocket connection error: ${error.message}`, 'error');
            }
        }

        // Update agent data
        function updateAgent(data) {
            const agent = agents.get(data.agentId);
            if (agent) {
                agent.mesh.userData.currentTask = data.task || 'Standby';
                agent.mesh.userData.taskProgress = data.progress || 0;
                agent.mesh.userData.state = data.state || 'idle';
            }
        }

        // Handle research completion with enhanced data
        function handleResearchComplete(data) {
            const researchStatus = document.getElementById('researchStatus');
            researchStatus.innerHTML = `
                <div style="color: #ffffff; padding: 6px; font-size: 9px; opacity: 0.7;">
                    Research completed: ${data.topic}
                </div>
            `;
            
            // Reset agent states
            agents.forEach((agent, index) => {
                if (agent.mesh && agent.mesh.userData) {
                    agent.mesh.userData.currentTask = 'Standby';
                    agent.mesh.userData.taskProgress = 0;
                    agent.mesh.userData.state = 'idle';
                }
            });
        }

        // Animation loop
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            if (!controls || !renderer || !scene || !camera) {
                return;
            }
            
            controls.update();
            
            const time = Date.now() * 0.001;
            
            // Animate agents with validation
            agents.forEach((agent, index) => {
                if (!agent || !agent.mesh) return;
                
                // Validate position before animation
                const pos = agent.mesh.position;
                if (isNaN(pos.x) || isNaN(pos.y) || isNaN(pos.z)) {
                    debugLog('Invalid agent position detected, resetting', 'error');
                    agent.mesh.position.set(0, 0, 0);
                    return;
                }
                
                // Smooth floating animation
                agent.mesh.position.y = agent.originalPosition.y + Math.sin(time + index * 0.5) * 0.15;
                agent.mesh.rotation.y += 0.008;
                
                // Animate glow and neural overlay
                if (agent.glow) {
                    agent.glow.position.copy(agent.mesh.position);
                    agent.glow.rotation.y += 0.01;
                }
                
                if (agent.neuralOverlay) {
                    agent.neuralOverlay.position.copy(agent.mesh.position);
                    agent.neuralOverlay.rotation.y += 0.015;
                    agent.neuralOverlay.rotation.x += 0.008;
                }
            });
            
            // Animate connections with validation
            connections.forEach((connection, index) => {
                if (!connection || !connection.userData || !connection.userData.agent1 || !connection.userData.agent2) {
                    return;
                }
                
                // Validate positions before updating geometry
                const pos1 = connection.userData.agent1.position;
                const pos2 = connection.userData.agent2.position;
                
                if (isNaN(pos1.x) || isNaN(pos1.y) || isNaN(pos1.z) ||
                    isNaN(pos2.x) || isNaN(pos2.y) || isNaN(pos2.z)) {
                    return; // Skip this connection
                }
                
                const points = [
                    pos1.clone(),
                    pos2.clone()
                ];
                
                try {
                    connection.geometry.setFromPoints(points);
                } catch (error) {
                    debugLog('Error updating connection geometry: ' + error.message, 'error');
                    return;
                }
                
                if (connection.material) {
                    connection.material.opacity = 0.4 + Math.sin(time * 3 + index) * 0.2;
                }
            });
            
            renderer.render(scene, camera);
        }

        // Mouse interaction
        function onMouseMove(event) {
            if (!THREE || !scene || !camera) {
                return;
            }
            
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(scene.children);

            // Reset all agent hover states
            agents.forEach(agent => {
                if (agent.mesh) agent.mesh.scale.setScalar(1);
                if (agent.glow) agent.glow.scale.setScalar(1);
            });

            let agentHovered = false;

            // Show tooltip for hovered agent
            for (let intersect of intersects) {
                if (intersect.object.userData && intersect.object.userData.name) {
                    const agent = intersect.object;
                    const userData = agent.userData;
                    
                    // Scale up hovered agent
                    agent.scale.setScalar(1.1);
                    if (agents.has(agent.userData.agentId)) {
                        const agentData = agents.get(agent.userData.agentId);
                        if (agentData.glow) agentData.glow.scale.setScalar(1.1);
                    }
                    
                    // Show tooltip
                    if (!hoverState.tooltipVisible || hoverState.currentAgent !== userData) {
                        showTooltip(userData, event.clientX, event.clientY);
                    }
                    agentHovered = true;
                    break;
                }
            }

            // Hide tooltip if no agent is hovered
            if (!agentHovered) {
                hideTooltipWithDelay();
            }
        }

        // Show tooltip
        function showTooltip(agentData, x, y) {
            if (tooltipHideTimeout) {
                clearTimeout(tooltipHideTimeout);
                tooltipHideTimeout = null;
            }

            hoverState.currentAgent = agentData;
            hoverState.tooltipVisible = true;
            hoverState.lastHoverTime = Date.now();

            let tooltip = document.getElementById('tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'tooltip';
                tooltip.style.cssText = `
                    position: fixed;
                    background: rgba(0, 0, 0, 0.95);
                    color: white;
                    padding: 15px;
                    border-radius: 12px;
                    font-family: 'Courier New', monospace;
                    font-size: 12px;
                    pointer-events: none;
                    z-index: 1000;
                    backdrop-filter: blur(15px);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    max-width: 320px;
                    box-shadow: 0 12px 48px rgba(0, 0, 0, 0.6);
                    transition: opacity 0.2s ease;
                `;
                document.body.appendChild(tooltip);
            }
            
            tooltip.innerHTML = `
                <div style="margin-bottom: 10px;">
                    <strong style="color: #${agentData.color ? agentData.color.toString(16).padStart(6, '0') : '00ff88'}; font-size: 14px;">${agentData.name}</strong>
                </div>
                <div style="margin-bottom: 8px; font-size: 11px; color: #ccc;">
                    <strong>Role:</strong> ${agentData.role || 'Research Agent'}<br>
                    <strong>Current Task:</strong> ${agentData.currentTask || 'Standby'}<br>
                    <strong>Status:</strong> <span style="color: #00ff88;">Active</span>
                </div>
                ${agentData.taskProgress > 0 ? `
                <div style="margin-top: 10px;">
                    <div style="background: rgba(255, 255, 255, 0.1); height: 6px; border-radius: 3px; overflow: hidden;">
                        <div style="background: linear-gradient(90deg, #00ff88, #00ccff); height: 100%; width: ${agentData.taskProgress}%; border-radius: 3px; transition: width 0.3s ease;"></div>
                    </div>
                    <div style="font-size: 10px; color: #888; margin-top: 6px;">Progress: ${Math.round(agentData.taskProgress)}%</div>
                </div>
                ` : ''}
                <div style="margin-top: 8px; font-size: 10px; color: #666; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px;">
                    Click for detailed information
                </div>
            `;
            
            // Position tooltip
            const tooltipRect = tooltip.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            let tooltipX = x + 15;
            let tooltipY = y - 15;
            
            if (tooltipX + tooltipRect.width > viewportWidth - 20) {
                tooltipX = x - tooltipRect.width - 15;
            }
            if (tooltipY + tooltipRect.height > viewportHeight - 20) {
                tooltipY = viewportHeight - tooltipRect.height - 20;
            }
            if (tooltipY < 20) {
                tooltipY = 20;
            }
            
            tooltip.style.left = tooltipX + 'px';
            tooltip.style.top = tooltipY + 'px';
            tooltip.style.display = 'block';
            tooltip.style.opacity = '1';
        }

        // Add event listeners
        function addEventListeners() {
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
        }

        // Handle window resize
        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // User research function - Multi-agent orchestration based on Anthropic's research system
        window.startUserResearch = function() {
            const researchTopic = document.getElementById('researchTopic').value.trim();
            const researchStatus = document.getElementById('researchStatus');
            
            if (!researchTopic) {
                researchStatus.innerHTML = '<div style="color: #ff6b6b; padding: 6px; font-size: 9px;">Enter topic</div>';
                return;
            }
            
            // Show research starting status
            researchStatus.innerHTML = `
                <div style="color: #ffffff; padding: 6px; font-size: 9px; opacity: 0.7;">
                    Research: ${researchTopic}
                </div>
            `;
            
            // Clear previous research
            clearResearchVisualizations();
            
            // Add new embedding points based on research topic
            addResearchEmbeddings(researchTopic);
            
            // Send research request to server with enhanced payload
            if (socket) {
                socket.emit('startUserResearch', { 
                    topic: researchTopic,
                    timestamp: Date.now(),
                    source: 'web_interface',
                    architecture: 'anthropic_research_system'
                });
                debugLog('Sent multi-agent research request: ' + researchTopic, 'info');
                
                // Update agent states to show they're working
                agents.forEach((agent, index) => {
                    if (agent.mesh && agent.mesh.userData) {
                        agent.mesh.userData.currentTask = 'Researching: ' + researchTopic;
                        agent.mesh.userData.taskProgress = 0;
                        agent.mesh.userData.state = 'processing';
                        agent.mesh.userData.lastInteraction = Date.now();
                    }
                });
                
                // Update status after a short delay
                setTimeout(() => {
                    researchStatus.innerHTML = `
                        <div style="color: #00ff88; padding: 6px; font-size: 9px; opacity: 0.7;">
                            Multi-agent research active
                        </div>
                    `;
                }, 2000);
                
            } else {
                researchStatus.innerHTML = `
                    <div style="color: #ff6b6b; padding: 6px; font-size: 9px;">
                        Connection lost. Please refresh.
                    </div>
                `;
                debugLog('Socket not connected for user research', 'error');
            }
        };

        // Legacy research function (for backward compatibility)
        window.startResearch = function() {
            debugLog('Legacy startResearch called', 'info');
            startUserResearch();
        };

        // Show architecture info
        window.showArchitectureInfo = function() {
            alert('Multi-Agent Research System\n\nBased on Anthropic\'s production multi-agent research architecture:\n\n- LeadResearcher: Orchestrates research process and coordinates subagents\n- Subagents: Specialized agents that search and analyze in parallel\n- Dynamic Task Decomposition: Queries broken into specialized subtasks\n- Parallel Information Gathering: Multiple agents search simultaneously\n- CitationAgent: Processes documents and adds proper citations\n- Memory Management: Handles long conversations and context limits\n\nKey Benefits:\n- 90.2% performance improvement over single-agent systems\n- Parallel exploration of multiple research directions\n- Efficient token usage across separate context windows\n- Real-time coordination and result synthesis\n\nBased on Anthropic\'s "How we built our multi-agent research system"');
        };

        // Initialize vector space visualization
        function initVectorSpace() {
            // Create vector scene
            vectorScene = new THREE.Scene();
            vectorScene.background = new THREE.Color(0x000000);
            
            // Create vector camera
            vectorCamera = new THREE.PerspectiveCamera(75, 400 / 300, 0.1, 1000);
            vectorCamera.position.set(0, 0, 8);
            
            // Create vector renderer container
            const vectorContainer = document.createElement('div');
            vectorContainer.style.cssText = `
                position: absolute;
                top: 25px;
                right: 25px;
                width: 400px;
                height: 350px;
                background: transparent;
                padding: 15px;
            `;
            
            // Add title
            const title = document.createElement('div');
            title.style.cssText = `
                color: #ffffff;
                font-size: 10px;
                font-weight: 400;
                text-align: center;
                margin-bottom: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                opacity: 0.6;
            `;
            title.textContent = 'Embedding Space';
            vectorContainer.appendChild(title);
            
            // Create canvas
            const vectorCanvas = document.createElement('canvas');
            vectorCanvas.width = 370;
            vectorCanvas.height = 270;
            vectorCanvas.style.cssText = `
                width: 100%;
                height: 270px;
                background: transparent;
            `;
            vectorContainer.appendChild(vectorCanvas);
            
            document.getElementById('ui').appendChild(vectorContainer);
            
            vectorRenderer = new THREE.WebGLRenderer({ 
                canvas: vectorCanvas,
                antialias: true,
                alpha: true
            });
            vectorRenderer.setSize(370, 270);
            
            // Add ambient light to vector scene
            const vectorAmbientLight = new THREE.AmbientLight(0x404040, 0.6);
            vectorScene.add(vectorAmbientLight);
            
            // Create initial embedding points with random initialization
            createRandomEmbeddingPoints();
            
            // Start vector space animation
            animateVectorSpace();
        }

        // Create random embedding points for cool initialization
        function createRandomEmbeddingPoints() {
            // Clear existing points
            vectorPoints.forEach(point => {
                if (point && point.geometry) {
                    point.geometry.dispose();
                }
            });
            vectorPoints = [];
            
            // Clear existing connections
            vectorConnections.forEach(connection => {
                if (connection && connection.geometry) {
                    connection.geometry.dispose();
                }
            });
            vectorConnections = [];
            
            // Create random embedding points
            const numPoints = 15 + Math.floor(Math.random() * 10); // 15-25 points
            
            for (let i = 0; i < numPoints; i++) {
                const point = createRandomEmbeddingPoint(i);
                vectorScene.add(point);
                vectorPoints.push(point);
            }
            
            // Create connections between nearby points
            createVectorConnections();
        }
        
        // Create a single random embedding point
        function createRandomEmbeddingPoint(index) {
            // Random position in 3D space
            const x = (Math.random() - 0.5) * 6;
            const y = (Math.random() - 0.5) * 4;
            const z = (Math.random() - 0.5) * 3;
            
            // Random color
            const hue = Math.random();
            const saturation = 0.6 + Math.random() * 0.4;
            const lightness = 0.5 + Math.random() * 0.3;
            const color = new THREE.Color().setHSL(hue, saturation, lightness);
            
            // Random size
            const size = 0.02 + Math.random() * 0.04;
            
            const geometry = new THREE.SphereGeometry(size, 8, 8);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8 + Math.random() * 0.2
            });
            
            const point = new THREE.Mesh(geometry, material);
            point.position.set(x, y, z);
            
            point.userData = {
                originalPosition: point.position.clone(),
                index: index,
                color: color,
                size: size,
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.01,
                    (Math.random() - 0.5) * 0.01,
                    (Math.random() - 0.5) * 0.01
                ),
                type: Math.random() > 0.7 ? 'research' : 'concept'
            };
            
            return point;
        }
        
        // Clear all research visualizations
        window.clearResearchVisualizations = function() {
            // Clear all points
            vectorPoints.forEach(point => {
                if (point && point.geometry) {
                    point.geometry.dispose();
                }
                vectorScene.remove(point);
            });
            vectorPoints = [];
            
            // Clear all connections
            vectorConnections.forEach(connection => {
                if (connection && connection.geometry) {
                    connection.geometry.dispose();
                }
                vectorScene.remove(connection);
            });
            vectorConnections = [];
            
            // Clear research status
            const researchStatus = document.getElementById('researchStatus');
            if (researchStatus) {
                researchStatus.innerHTML = '';
            }
            
            // Recreate random embedding points
            createRandomEmbeddingPoints();
        };

        // Add new embedding points based on research topic
        function addResearchEmbeddings(topic) {
            // Generate a color based on the topic hash
            const topicHash = topic.split('').reduce((a, b) => {
                a = ((a << 5) - a) + b.charCodeAt(0);
                return a & a;
            }, 0);
            const hue = Math.abs(topicHash) % 360 / 360;
            const color = new THREE.Color().setHSL(hue, 0.8, 0.7);
            
            // Create research topic node (larger and more prominent)
            const mainGeometry = new THREE.SphereGeometry(0.12, 16, 16);
            const mainMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.9
            });
            
            const mainPoint = new THREE.Mesh(mainGeometry, mainMaterial);
            
            // Position research topic in a strategic location
            const angle = Math.random() * Math.PI * 2;
            const radius = 1.5 + Math.random() * 1;
            
            mainPoint.position.set(
                Math.cos(angle) * radius,
                Math.sin(angle) * radius * 0.5,
                (Math.random() - 0.5) * 1
            );
            
            mainPoint.userData = {
                originalPosition: mainPoint.position.clone(),
                topic: topic,
                isResearchTopic: true,
                creationTime: Date.now(),
                color: color,
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.005,
                    (Math.random() - 0.5) * 0.005,
                    (Math.random() - 0.5) * 0.005
                ),
                type: 'research',
                pulseIntensity: 1.0
            };
            
            vectorScene.add(mainPoint);
            vectorPoints.push(mainPoint);
            
            // Add related concept nodes around the research topic
            addRelatedConcepts(topic, mainPoint, color);
            
            // Start multi-agent workflow
            startMultiAgentWorkflow(topic, mainPoint);
        }
        
        // Add related concept nodes
        function addRelatedConcepts(topic, mainPoint, mainColor) {
            const concepts = generateRelatedConcepts(topic);
            
            concepts.forEach((concept, index) => {
                const conceptColor = new THREE.Color(mainColor);
                conceptColor.offsetHSL(0, 0, (Math.random() - 0.5) * 0.2);
                
                const conceptGeometry = new THREE.SphereGeometry(0.06, 12, 12);
                const conceptMaterial = new THREE.MeshBasicMaterial({
                    color: conceptColor,
                    transparent: true,
                    opacity: 0.8
                });
                
                const conceptPoint = new THREE.Mesh(conceptGeometry, conceptMaterial);
                
                // Position around the main topic
                const angle = (index / concepts.length) * Math.PI * 2;
                const radius = 0.8 + Math.random() * 0.4;
                
                conceptPoint.position.set(
                    mainPoint.position.x + Math.cos(angle) * radius,
                    mainPoint.position.y + Math.sin(angle) * radius,
                    mainPoint.position.z + (Math.random() - 0.5) * 0.3
                );
                
                conceptPoint.userData = {
                    originalPosition: conceptPoint.position.clone(),
                    topic: concept,
                    isConcept: true,
                    parentTopic: topic,
                    creationTime: Date.now(),
                    color: conceptColor,
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.003,
                        (Math.random() - 0.5) * 0.003,
                        (Math.random() - 0.5) * 0.003
                    ),
                    type: 'concept',
                    pulseIntensity: 0.7
                };
                
                vectorScene.add(conceptPoint);
                vectorPoints.push(conceptPoint);
            });
        }
        
        // Start multi-agent workflow based on Anthropic's research system
        function startMultiAgentWorkflow(topic, mainPoint) {
            const agentWorkflows = [
                {
                    agentId: 'agent_0',
                    role: 'LeadResearcher',
                    color: 0x00ff88,
                    delay: 500,
                    tasks: ['Planning research approach', 'Decomposing query', 'Coordinating subagents']
                },
                {
                    agentId: 'agent_1', 
                    role: 'WebSearch Agent',
                    color: 0x0088ff,
                    delay: 1500,
                    tasks: ['Searching web sources', 'Evaluating relevance', 'Extracting key information']
                },
                {
                    agentId: 'agent_2',
                    role: 'Analysis Agent',
                    color: 0xff8800,
                    delay: 2500,
                    tasks: ['Analyzing findings', 'Identifying patterns', 'Synthesizing insights']
                },
                {
                    agentId: 'agent_3',
                    role: 'Citation Agent',
                    color: 0xff0088,
                    delay: 3500,
                    tasks: ['Processing documents', 'Adding citations', 'Validating sources']
                }
            ];
            
            // Start each agent's workflow with enhanced interactions
            agentWorkflows.forEach((workflow, index) => {
                setTimeout(() => {
                    addAgentNode(topic, mainPoint, workflow, index);
                }, workflow.delay);
            });
            
            // Add dynamic agent interactions
            setTimeout(() => {
                startAgentInteractions();
            }, 5000);
        }
        
        // Start dynamic agent interactions
        function startAgentInteractions() {
            // Find research topic and agent nodes
            const researchTopic = vectorPoints.find(p => p.userData.isResearchTopic);
            const agentNodes = vectorPoints.filter(p => p.userData.agentId);
            
            if (researchTopic && agentNodes.length > 0) {
                // Create interaction patterns
                setInterval(() => {
                    // Random agent interactions
                    agentNodes.forEach(agent => {
                        // Add some random movement towards research topic
                        const direction = new THREE.Vector3().subVectors(researchTopic.position, agent.position).normalize();
                        agent.userData.velocity.add(direction.multiplyScalar(0.001));
                        
                        // Pulse effect for active agents
                        agent.userData.pulseIntensity = 1.2;
                        setTimeout(() => {
                            agent.userData.pulseIntensity = 1.0;
                        }, 500);
                    });
                }, 2000);
            }
        }
        
        // Add agent node to embedding space
        function addAgentNode(topic, mainPoint, workflow, index) {
            const agentColor = new THREE.Color(workflow.color);
            
            // Create agent node
            const agentGeometry = new THREE.SphereGeometry(0.08, 12, 12);
            const agentMaterial = new THREE.MeshBasicMaterial({
                color: agentColor,
                transparent: true,
                opacity: 0.9
            });
            
            const agentPoint = new THREE.Mesh(agentGeometry, agentMaterial);
            
            // Position agent around the main topic
            const agentAngle = (index / 4) * Math.PI * 2;
            const agentRadius = 1.5;
            
            agentPoint.position.set(
                mainPoint.position.x + Math.cos(agentAngle) * agentRadius,
                mainPoint.position.y + Math.sin(agentAngle) * agentRadius,
                mainPoint.position.z + (Math.random() - 0.5) * 0.4
            );
            
            agentPoint.userData = {
                originalPosition: agentPoint.position.clone(),
                topic: workflow.role,
                isAgent: true,
                parentTopic: topic,
                creationTime: Date.now(),
                color: agentColor,
                agentId: workflow.agentId,
                role: workflow.role,
                tasks: workflow.tasks,
                currentTaskIndex: 0,
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.002,
                    (Math.random() - 0.5) * 0.002,
                    (Math.random() - 0.5) * 0.002
                ),
                type: 'agent',
                pulseIntensity: 1.0
            };
            
            vectorScene.add(agentPoint);
            vectorPoints.push(agentPoint);
            
            // Start agent's task progression
            startAgentTaskProgression(agentPoint, workflow);
        }
        
        // Start agent's task progression
        function startAgentTaskProgression(agentPoint, workflow) {
            let taskIndex = 0;
            
            const taskInterval = setInterval(() => {
                if (taskIndex >= workflow.tasks.length) {
                    clearInterval(taskInterval);
                    return;
                }
                
                const currentTask = workflow.tasks[taskIndex];
                agentPoint.userData.currentTaskIndex = taskIndex;
                
                // Add task node
                addTaskNode(currentTask, agentPoint, workflow.color);
                
                // Update agent status
                updateAgentStatus(workflow.agentId, currentTask, (taskIndex + 1) * 25);
                
                taskIndex++;
            }, 3000); // New task every 3 seconds
        }
        
        // Update agent status (placeholder function)
        function updateAgentStatus(agentId, task, progress) {
            // This function can be expanded to update main agent visualization
            console.log(`Agent ${agentId}: ${task} - ${progress}%`);
        }
        
        // Add task node
        function addTaskNode(task, agentPoint, agentColor) {
            const taskColor = new THREE.Color(agentColor);
            taskColor.multiplyScalar(0.6); // Dimmer than agent
            
            const taskGeometry = new THREE.SphereGeometry(0.04, 8, 8);
            const taskMaterial = new THREE.MeshBasicMaterial({
                color: taskColor,
                transparent: true,
                opacity: 0.7
            });
            
            const taskPoint = new THREE.Mesh(taskGeometry, taskMaterial);
            
            // Position task near the agent
            const taskAngle = Math.random() * Math.PI * 2;
            const taskRadius = 0.8;
            
            taskPoint.position.set(
                agentPoint.position.x + Math.cos(taskAngle) * taskRadius,
                agentPoint.position.y + Math.sin(taskAngle) * taskRadius,
                agentPoint.position.z + (Math.random() - 0.5) * 0.3
            );
            
            taskPoint.userData = {
                originalPosition: taskPoint.position.clone(),
                topic: task,
                isTask: true,
                parentTopic: agentPoint.userData.topic,
                creationTime: Date.now(),
                color: taskColor,
                agentId: agentPoint.userData.agentId,
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.001,
                    (Math.random() - 0.5) * 0.001,
                    (Math.random() - 0.5) * 0.001
                ),
                type: 'task',
                pulseIntensity: 0.8
            };
            
            vectorScene.add(taskPoint);
            vectorPoints.push(taskPoint);
        }
        
        // Generate related concepts based on the research topic
        function generateRelatedConcepts(topic) {
            const topicLower = topic.toLowerCase();
            const concepts = [];
            
            // Enhanced keyword-based concept generation
            if (topicLower.includes('quantum')) {
                concepts.push('Superposition', 'Entanglement', 'Qubits', 'Quantum Gates', 'Decoherence');
            } else if (topicLower.includes('ai') || topicLower.includes('artificial intelligence')) {
                concepts.push('Machine Learning', 'Neural Networks', 'Deep Learning', 'Natural Language Processing', 'Computer Vision');
            } else if (topicLower.includes('blockchain')) {
                concepts.push('Cryptography', 'Smart Contracts', 'Decentralization', 'Consensus', 'Distributed Ledger');
            } else if (topicLower.includes('climate')) {
                concepts.push('Global Warming', 'Carbon Emissions', 'Renewable Energy', 'Sustainability', 'Green Technology');
            } else if (topicLower.includes('space') || topicLower.includes('astronomy')) {
                concepts.push('Planets', 'Stars', 'Galaxies', 'Cosmology', 'Dark Matter');
            } else if (topicLower.includes('health') || topicLower.includes('medical')) {
                concepts.push('Genetics', 'Drug Discovery', 'Clinical Trials', 'Biotechnology', 'Precision Medicine');
            } else if (topicLower.includes('llm') || topicLower.includes('language model')) {
                concepts.push('Transformer Architecture', 'Attention Mechanisms', 'Fine-tuning', 'Prompt Engineering', 'Multimodal AI');
            } else if (topicLower.includes('agent') || topicLower.includes('multi-agent')) {
                concepts.push('Orchestration', 'Task Decomposition', 'Parallel Processing', 'Agent Communication', 'Emergent Behavior');
            } else {
                // Generic concepts for any topic
                concepts.push('Research', 'Analysis', 'Innovation', 'Technology', 'Discovery');
            }
            
            return concepts.slice(0, 4); // Return max 4 concepts
        }

        // Create connections between vector points
        function createVectorConnections() {
            // Clear existing connections
            vectorConnections.forEach(connection => {
                if (connection && connection.geometry) {
                    connection.geometry.dispose();
                }
            });
            vectorConnections = [];
            
            // Connect nearby points based on distance
            for (let i = 0; i < vectorPoints.length; i++) {
                const point1 = vectorPoints[i];
                if (!point1 || !point1.userData) continue;
                
                for (let j = i + 1; j < vectorPoints.length; j++) {
                    const point2 = vectorPoints[j];
                    if (!point2 || !point2.userData) continue;
                    
                    const distance = point1.position.distanceTo(point2.position);
                    
                    // Connect points that are close to each other
                    if (distance < 1.5) {
                        const connectionColor = point1.userData.color.getHex();
                        const connectionOpacity = 0.3 - (distance / 1.5) * 0.2; // Closer = more opaque
                        
                        const points = [
                            point1.position.clone(),
                            point2.position.clone()
                        ];
                        
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const material = new THREE.LineBasicMaterial({
                            color: connectionColor,
                            transparent: true,
                            opacity: connectionOpacity
                        });
                        
                        const line = new THREE.Line(geometry, material);
                        line.userData = {
                            point1: point1,
                            point2: point2,
                            distance: distance
                        };
                        
                        vectorScene.add(line);
                        vectorConnections.push(line);
                    }
                }
            }
        }
        
        // Get connection type for visualization
        function getConnectionType(point1, point2) {
            if (point1.userData.isMainTopic || point2.userData.isMainTopic) {
                return 'orchestrator-to-agent';
            } else if (point1.userData.isTask || point2.userData.isTask) {
                return 'agent-to-task';
            } else {
                return 'agent-collaboration';
            }
        }

        // Animate vector space with dynamic interactions
        function animateVectorSpace() {
            if (!vectorRenderer || !vectorScene || !vectorCamera) return;
            
            const time = Date.now() * 0.001;
            
            // Animate embedding points with physics-like behavior
            vectorPoints.forEach((point, index) => {
                if (!point || !point.userData) return;
                
                const userData = point.userData;
                
                // Apply velocity
                point.position.add(userData.velocity);
                
                // Bounce off boundaries
                if (Math.abs(point.position.x) > 3) {
                    userData.velocity.x *= -0.8;
                    point.position.x = Math.sign(point.position.x) * 3;
                }
                if (Math.abs(point.position.y) > 2) {
                    userData.velocity.y *= -0.8;
                    point.position.y = Math.sign(point.position.y) * 2;
                }
                if (Math.abs(point.position.z) > 1.5) {
                    userData.velocity.z *= -0.8;
                    point.position.z = Math.sign(point.position.z) * 1.5;
                }
                
                // Gentle attraction to center
                const centerAttraction = new THREE.Vector3(0, 0, 0).sub(point.position).multiplyScalar(0.0001);
                userData.velocity.add(centerAttraction);
                
                // Damping
                userData.velocity.multiplyScalar(0.999);
                
                // Rotate slowly
                point.rotation.y += 0.01;
                point.rotation.x += 0.005;
                
                // Pulse effect
                const scale = 1 + Math.sin(time * 3 + index) * 0.1;
                point.scale.setScalar(scale);
            });
            
            // Update connections dynamically
            updateVectorConnections();
            
            // Animate connections
            vectorConnections.forEach((connection, index) => {
                if (!connection || !connection.userData) return;
                
                // Update connection positions
                const point1 = connection.userData.point1;
                const point2 = connection.userData.point2;
                
                if (point1 && point2) {
                    const points = [point1.position.clone(), point2.position.clone()];
                    connection.geometry.setFromPoints(points);
                    
                    // Animate opacity based on distance
                    const distance = point1.position.distanceTo(point2.position);
                    const opacity = Math.max(0, 0.4 - distance * 0.2);
                    connection.material.opacity = opacity;
                }
            });
            
            // Dynamic camera movement
            vectorCamera.position.x = Math.cos(time * 0.3) * 8;
            vectorCamera.position.y = Math.sin(time * 0.2) * 2;
            vectorCamera.position.z = Math.sin(time * 0.4) * 8;
            vectorCamera.lookAt(0, 0, 0);
            
            vectorRenderer.render(vectorScene, vectorCamera);
            requestAnimationFrame(animateVectorSpace);
        }
        
        // Update vector connections dynamically
        function updateVectorConnections() {
            // Remove old connections
            vectorConnections.forEach(connection => {
                if (connection && connection.geometry) {
                    connection.geometry.dispose();
                }
                vectorScene.remove(connection);
            });
            vectorConnections = [];
            
            // Create new connections based on current positions
            for (let i = 0; i < vectorPoints.length; i++) {
                const point1 = vectorPoints[i];
                if (!point1 || !point1.userData) continue;
                
                for (let j = i + 1; j < vectorPoints.length; j++) {
                    const point2 = vectorPoints[j];
                    if (!point2 || !point2.userData) continue;
                    
                    const distance = point1.position.distanceTo(point2.position);
                    
                    // Connect points that are close to each other
                    if (distance < 1.2) {
                        const connectionColor = point1.userData.color.getHex();
                        const connectionOpacity = 0.4 - (distance / 1.2) * 0.3;
                        
                        const points = [
                            point1.position.clone(),
                            point2.position.clone()
                        ];
                        
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const material = new THREE.LineBasicMaterial({
                            color: connectionColor,
                            transparent: true,
                            opacity: connectionOpacity
                        });
                        
                        const line = new THREE.Line(geometry, material);
                        line.userData = {
                            point1: point1,
                            point2: point2,
                            distance: distance
                        };
                        
                        vectorScene.add(line);
                        vectorConnections.push(line);
                    }
                }
            }
        }

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
