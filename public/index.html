<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Agent System Visualizer - Anthropic Architecture</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="alternate icon" href="favicon.svg">
    
    <!-- Use jsdelivr CDN for Three.js ES modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
            "three/addons/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/controls/OrbitControls.js"
        }
    }
    </script>
    
    <!-- Socket.io CDN -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    
    <!-- External CSS -->
    <link rel="stylesheet" href="css/styles.css">
    
    <!-- External JavaScript utilities -->
    <script src="js/config.js"></script>
    <script src="js/utils.js"></script>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="ui">
            <div id="header">
                <h1>Multi-Agent  System Visualizer</h1>
                <p>Powered by 
                    <span class="tech-links">
                        <a href="https://docs.astro.build/en/getting-started/" target="_blank" class="tech-link">Astro</a>
                        <span style="color: #666;"> + </span>
                        <a href="https://www.langchain.com/langgraph" target="_blank" class="tech-link">LangGraph</a>
                    </span>
                </p>
                <div class="header-links">
                    <div class="architecture-info">
                        <a href="#" onclick="showArchitectureInfo()">ANTHROPIC ARCHITECTURE</a>
                    </div>
                    <div class="architecture-info">
                        <a href="https://github.com/abdulmalikds" target="_blank">@ABDULMALIKDS</a>
                    </div>
                </div>
            </div>

            <div id="embedding-space">
                <div id="embedding-space-label">Embedding Space</div>
                <canvas id="embedding-canvas"></canvas>
            </div>

            <div id="research-panel">
                <h3>Research</h3>
                <div class="research-input-container">
                    <input type="text" id="researchTopic" placeholder="Enter research topic..." class="research-input">
                    <button onclick="startUserResearch()" class="research-button">Search</button>
                </div>
                
                <div class="research-controls">
                    <button onclick="clearResearchVisualizations()" class="clear-button">Clear</button>
                    <button onclick="exportResearchResults()" class="clear-button">Export</button>
                </div>
                <div class="research-status" id="researchStatus"></div>
            </div>
        </div>
        
        <div id="loading">
            <h2>Initializing Research Network...</h2>
            <div class="spinner"></div>
        </div>
        
        <div id="error-message" style="display: none;">
            <h2>Critical Error</h2>
            <p>Could not load essential components. Please refresh the page.</p>
        </div>
        
        <div id="tooltip"></div>
    </div>
    
    <script type="module">
        // Import Three.js modules
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls';

        // Define research results template
        const RESEARCH_RESULTS_TEMPLATE = {
            startTime: 0,
            endTime: 0,
            topic: '',
            totalResults: 0,
            perplexityResults: [],
            agentAnalysis: [],
            citations: [],
            embeddingPoints: [],
            finalSummary: '',
            keyFindings: []
        };

        // Global variables
        let scene, camera, renderer, controls;
        let agents = new Map();
        let connections = [];
        let particles = []; // For visualizing interactions
        let embeddings = []; // Embeddings in main scene - starts empty, no initial embeddings
        let socket;
        
        // Enhanced interaction system
        let agentStates = new Map(); // Track agent workload and state
        let dataPackets = []; // Animated data flow particles

        // Enhanced visual effects
        let particleSystem = null;
        let dataFlowParticles = [];
        let backgroundStars = null;
        let dynamicLights = [];
        let pulsingConnections = [];
        let agentTrails = new Map();

        // Embedding space visualization
        let embeddingScene, embeddingCamera, embeddingRenderer;
        let embeddingPoints = [];
        let embeddingConnections = [];
        let embeddingAnimationId;
        let isResearchActive = false;
        let researchStartTime = 0;
        let totalInteractions = 0;
        let researchTopic = '';
        let researchResults = {...RESEARCH_RESULTS_TEMPLATE}; // Use external template
        
        // Smart Hover State Management System
        let hoverState = {
            currentAgent: null,
            tooltipVisible: false,
            hoverTimeout: null,
            lastHoverTime: 0
        };

        // Timeout ID for delayed tooltip hiding
        let tooltipHideTimeout = null;
        
        // Initialize the application
        async function init() {
            try {
                console.log('üöÄ Starting application initialization...');
                
                // Three.js is now available via ES modules - no need to check for loading
                console.log('‚úÖ Three.js loaded via ES modules');
                
                console.log('ÔøΩ Initializing Three.js scene...');
                // Initialize Three.js components
                initThreeJS();
                
                console.log('üèóÔ∏è Creating initial agents...');
                createInitialAgents();
                
                console.log('ÔøΩ Initializing embedding space...');
                // Initialize embedding space
                initEmbeddingSpace();
                
                console.log('üîå Initializing WebSocket connection...');
                // Initialize WebSocket connection
                initWebSocket();
                
                console.log('üé¨ Starting animation loop...');
                // Start the animation loop
                animate();
                
                // Hide loading screen with fade effect
                const loadingScreen = document.getElementById('loading');
                if (loadingScreen) {
                    loadingScreen.style.opacity = '0';
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                    }, 500);
                }
                
                console.log('‚úÖ Application initialized successfully');
                
            } catch (error) {
                console.error('‚ùå Initialization error:', error);
                throw error;
            }
        }

        // Scene setup with darker background like reference
        function initThreeJS() {
            console.log('üé® Setting up Three.js scene...');
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // Match reference background
            
            console.log('üì∑ Setting up camera...');
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 18); // Adjusted for a better view
            
            console.log('üñ•Ô∏è Setting up renderer...');
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            console.log('üéÆ Setting up controls...');
            // OrbitControls are now available via ES modules
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 10;
            controls.maxDistance = 100;
            console.log('‚úÖ OrbitControls initialized via ES modules');
            
            console.log('üí° Setting up lighting...');
            // Enhanced lighting for cinematic visualization
            const ambientLight = new THREE.AmbientLight(0x404040, 1.2); // Much brighter ambient
            scene.add(ambientLight);
            
            // Primary directional light with shadows
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.8); // Brighter
            directionalLight.position.set(15, 15, 8);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 50;
            scene.add(directionalLight);
            
            // Rim lighting for agents
            const rimLight = new THREE.DirectionalLight(0x00ffff, 1.2); // Brighter
            rimLight.position.set(-10, 5, -10);
            scene.add(rimLight);
            
            // Dynamic accent light that follows camera
            const accentLight = new THREE.PointLight(0x88ff88, 1.0, 30); // Brighter
            accentLight.position.set(0, 8, 0);
            scene.add(accentLight);
            
            // Add volumetric fog for depth
            scene.fog = new THREE.Fog(0x000000, 15, 60); // Adjusted for brighter scene
            
            // Enable shadows
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            console.log('‚úÖ Three.js scene initialized');
        }

        // Create initial agents in an Anthropic-inspired architectural formation
        function createInitialAgents() {
            console.log('üìã Defining agent data...');
            const agentData = [
                // Central Lead Agent (Orchestrator) - Diamond shape, larger
                { 
                    name: 'Lead Orchestrator', 
                    role: 'Research Orchestrator', 
                    color: 0x00ff88, 
                    position: [0, 2, 0], 
                    size: 1.0,
                    shape: 'diamond',
                    description: 'Main orchestrator coordinating all research activities',
                    specialization: 'orchestration'
                },
                
                // Memory - Stack of cubes to represent memory layers
                { 
                    name: 'Memory', 
                    role: 'Persistent Storage', 
                    color: 0x6644aa, 
                    position: [4, 1.5, -1], 
                    size: 0.6,
                    shape: 'database',
                    description: 'Vector database for context and memory storage',
                    specialization: 'database'
                },
                
                // Tools - Hammer shape for tool repository
                { 
                    name: 'Tools', 
                    role: 'API Repository', 
                    color: 0xaa6644, 
                    position: [-4, 1.5, -1], 
                    size: 0.6,
                    shape: 'hammer',
                    description: 'Tool registry and API management system',
                    specialization: 'tools'
                },
                
                // Search Subagents - Spheres in formation
                { 
                    name: 'Search Agent Alpha', 
                    role: 'Primary Search', 
                    color: 0x0088ff, 
                    position: [-2.5, -1.5, 2], 
                    size: 0.6,
                    shape: 'sphere',
                    description: 'Specialized web search and information retrieval',
                    specialization: 'search'
                },
                { 
                    name: 'Search Agent Beta', 
                    role: 'Parallel Search', 
                    color: 0x0088ff, 
                    position: [0, -2, 3], 
                    size: 0.6,
                    shape: 'sphere',
                    description: 'Parallel search processing for comprehensive coverage',
                    specialization: 'search'
                },
                { 
                    name: 'Search Agent Gamma', 
                    role: 'Multi-Source Search', 
                    color: 0x0088ff, 
                    position: [2.5, -1.5, 2], 
                    size: 0.6,
                    shape: 'sphere',
                    description: 'Aggregates results from multiple search sources',
                    specialization: 'search'
                },
                
                // Citations and Analysis Agent - Octahedron for analysis
                { 
                    name: 'Citations Agent', 
                    role: 'Source Verification', 
                    color: 0xff0088, 
                    position: [3, 0, -3], 
                    size: 0.7,
                    shape: 'octahedron',
                    description: 'Validates sources and manages citations',
                    specialization: 'citations'
                },
                
                // Analysis and Synthesis Agent - Tetrahedron for synthesis
                { 
                    name: 'Synthesis Agent', 
                    role: 'Knowledge Synthesis', 
                    color: 0x88ff00, 
                    position: [-3, 0, -3], 
                    size: 0.7,
                    shape: 'tetrahedron',
                    description: 'Analyzes and synthesizes information into insights',
                    specialization: 'synthesis'
                }
            ];
            
            console.log(`ü§ñ Creating ${agentData.length} specialized agents...`);
            agentData.forEach((data, index) => {
                console.log(`Creating ${data.specialization} agent: ${data.name}`);
                createAgent(data, index);
            });
            
            // Create architectural connections
            console.log('üîó Creating architectural agent connections...');
            createAgentConnections();
            console.log('‚úÖ Multi-agent architecture initialized');
        }

        // Create a single agent with specialized geometry and labels
        function createAgent(data, index) {
            let geometry;
            let shouldHaveGlow = false;
            
            // Create different geometries based on agent specialization
            switch(data.shape || 'sphere') {
                case 'diamond':
                    geometry = new THREE.OctahedronGeometry(data.size * 0.8, 0);
                    shouldHaveGlow = true; // Lead orchestrator should glow
                    break;
                case 'hammer':
                    // Create hammer shape using grouped geometries
                    const hammerGroup = new THREE.Group();
                    
                    // Hammer handle (long cylinder)
                    const handleGeometry = new THREE.CylinderGeometry(data.size * 0.15, data.size * 0.15, data.size * 2, 8);
                    const handleMaterial = new THREE.MeshLambertMaterial({ 
                        color: new THREE.Color(data.color).multiplyScalar(0.7),
                        transparent: true,
                        opacity: 0.8
                    });
                    const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                    handle.position.y = -data.size * 0.3;
                    hammerGroup.add(handle);
                    
                    // Hammer head (box)
                    const headGeometry = new THREE.BoxGeometry(data.size * 1.2, data.size * 0.5, data.size * 0.4);
                    const headMaterial = new THREE.MeshLambertMaterial({ 
                        color: data.color,
                        transparent: true,
                        opacity: 0.85
                    });
                    const head = new THREE.Mesh(headGeometry, headMaterial);
                    head.position.y = data.size * 0.7;
                    hammerGroup.add(head);
                    
                    geometry = hammerGroup;
                    break;
                case 'database':
                    // Create database-like stacked cylinders
                    const dbGroup = new THREE.Group();
                    for (let i = 0; i < 3; i++) {
                        const diskGeometry = new THREE.CylinderGeometry(data.size * 0.8, data.size * 0.8, data.size * 0.2, 16);
                        const diskMaterial = new THREE.MeshLambertMaterial({ 
                            color: data.color,
                            transparent: true,
                            opacity: 0.8
                        });
                        const disk = new THREE.Mesh(diskGeometry, diskMaterial);
                        disk.position.y = i * data.size * 0.3 - data.size * 0.3;
                        dbGroup.add(disk);
                    }
                    geometry = dbGroup;
                    break;
                case 'cube':
                    geometry = new THREE.BoxGeometry(data.size * 1.2, data.size * 1.2, data.size * 1.2);
                    break;
                case 'hexagon':
                    geometry = new THREE.CylinderGeometry(data.size * 0.8, data.size * 0.8, data.size * 0.4, 6);
                    break;
                case 'octahedron':
                    geometry = new THREE.OctahedronGeometry(data.size * 0.7, 0);
                    shouldHaveGlow = true; // Citations agent should glow
                    break;
                case 'tetrahedron':
                    geometry = new THREE.TetrahedronGeometry(data.size * 0.8, 0);
                    shouldHaveGlow = true; // Synthesis agent should glow
                    break;
                default: // sphere - search agents
                    geometry = new THREE.SphereGeometry(data.size, 16, 16);
                    shouldHaveGlow = true; // Search agents should glow
            }
            
            let mesh;
            if (data.shape === 'database' || data.shape === 'hammer') {
                // For database and hammer, geometry is already a group
                mesh = geometry;
                mesh.position.set(...data.position);
            } else {
                const material = new THREE.MeshLambertMaterial({ 
                    color: data.color,
                    transparent: true,
                    opacity: 0.95, // Made more opaque
                    emissive: shouldHaveGlow ? data.color : 0x000000,
                    emissiveIntensity: shouldHaveGlow ? 0.3 : 0.1 // Much brighter emissive
                });
                
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(...data.position);
            }
            
            // Add glow effect only for agents (not databases)
            let glowMesh = null;
            if (shouldHaveGlow && data.shape !== 'database') {
                const glowGeometry = geometry.clone();
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: data.color,
                    transparent: true,
                    opacity: 0.4, // Made brighter
                    side: THREE.BackSide
                });
                glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                glowMesh.scale.multiplyScalar(1.5); // Larger glow
                glowMesh.position.copy(mesh.position);
            }
            
            // Create text label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            // Style the text
            context.font = 'bold 18px Arial';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.fillText(data.name, 128, 32);
            
            // Create texture from canvas
            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                alphaTest: 0.1
            });
            const labelSprite = new THREE.Sprite(labelMaterial);
            labelSprite.scale.set(2.5, 0.6, 1);
            labelSprite.position.set(data.position[0], data.position[1] + data.size + 1, data.position[2]);
            
            // Store agent data with enhanced state tracking
            mesh.userData = {
                name: data.name,
                role: data.role,
                color: data.color,
                agentId: `agent_${index}`,
                state: 'idle', // idle, working, busy, overloaded
                currentTask: 'Standby',
                taskProgress: 0,
                lastInteraction: Date.now(),
                originalScale: (data.shape === 'database' || data.shape === 'hammer') ? 1.0 : data.size,
                specialization: data.specialization,
                description: data.description,
                shape: data.shape || 'sphere',
                label: labelSprite,
                glow: glowMesh,
                isDatabase: data.specialization === 'database',
                workload: 0, // 0-1 scale
                efficiency: 0.8 + Math.random() * 0.2 // 80-100% efficiency
            };
            
            // Initialize agent state tracking
            agentStates.set(`agent_${index}`, {
                workload: 0,
                queueLength: 0,
                lastActivity: Date.now(),
                state: 'idle'
            });
            
            // Add to scene
            scene.add(mesh);
            if (glowMesh) {
                scene.add(glowMesh);
            }
            scene.add(labelSprite);
            
            agents.set(`agent_${index}`, { 
                mesh, 
                data,
                id: `agent_${index}` // Add ID for connection tracking
            });
            
            console.log(`‚úÖ Created ${data.specialization} ${data.specialization === 'database' ? 'database' : 'agent'}: ${data.name} (${data.shape || 'sphere'})`);
        }

        // Create connections in an architectural multi-agent system pattern
        function createAgentConnections() {
            const agentKeys = Array.from(agents.keys());
            
            // Primary architectural connections (Lead Orchestrator at center)
            const leadOrchestrator = agents.get('agent_0'); // Lead Orchestrator
            const memorySystem = agents.get('agent_1');     // Memory System
            const toolAgent = agents.get('agent_2');        // Tool Agent
            const searchAlpha = agents.get('agent_3');      // Search Agent Alpha
            const searchBeta = agents.get('agent_4');       // Search Agent Beta  
            const searchGamma = agents.get('agent_5');      // Search Agent Gamma
            const citationsAgent = agents.get('agent_6');   // Citations Agent
            const synthesisAgent = agents.get('agent_7');   // Synthesis Agent
            
            // Core architectural connections - Lead Orchestrator to key systems
            const primaryConnections = [
                { from: leadOrchestrator, to: memorySystem, color: 0x8800ff, opacity: 0.6, width: 3 },
                { from: leadOrchestrator, to: toolAgent, color: 0xff8800, opacity: 0.6, width: 3 },
                { from: leadOrchestrator, to: citationsAgent, color: 0xff0088, opacity: 0.5, width: 2 },
                { from: leadOrchestrator, to: synthesisAgent, color: 0x88ff00, opacity: 0.5, width: 2 }
            ];
            
            // Search agent cluster connections
            const searchConnections = [
                { from: leadOrchestrator, to: searchAlpha, color: 0x0088ff, opacity: 0.4, width: 2 },
                { from: leadOrchestrator, to: searchBeta, color: 0x0088ff, opacity: 0.4, width: 2 },
                { from: leadOrchestrator, to: searchGamma, color: 0x0088ff, opacity: 0.4, width: 2 },
                { from: searchAlpha, to: searchBeta, color: 0x0088ff, opacity: 0.3, width: 1 },
                { from: searchBeta, to: searchGamma, color: 0x0088ff, opacity: 0.3, width: 1 },
                { from: searchGamma, to: searchAlpha, color: 0x0088ff, opacity: 0.3, width: 1 }
            ];
            
            // Data flow connections (functional relationships)
            const dataFlowConnections = [
                { from: searchAlpha, to: citationsAgent, color: 0x4488ff, opacity: 0.3, width: 1 },
                { from: searchBeta, to: citationsAgent, color: 0x4488ff, opacity: 0.3, width: 1 },
                { from: searchGamma, to: citationsAgent, color: 0x4488ff, opacity: 0.3, width: 1 },
                { from: citationsAgent, to: synthesisAgent, color: 0xff4488, opacity: 0.4, width: 2 },
                { from: synthesisAgent, to: memorySystem, color: 0x88ff88, opacity: 0.4, width: 2 },
                { from: toolAgent, to: searchAlpha, color: 0xff8844, opacity: 0.3, width: 1 },
                { from: memorySystem, to: synthesisAgent, color: 0xaa88ff, opacity: 0.3, width: 1 }
            ];
            
            // Create all connections with research-aware materials
            function createConnection(connectionData) {
                if (connectionData.from && connectionData.to) {
                    const points = [
                        connectionData.from.mesh.position.clone(),
                        connectionData.to.mesh.position.clone()
                    ];
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    
                    // Use LineBasicMaterial for connections (no emissive support needed for lines)
                    const material = new THREE.LineBasicMaterial({
                        color: connectionData.color,
                        transparent: true,
                        opacity: connectionData.opacity * 1.5 // Brighter connections
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    line.userData = {
                        type: 'agent_connection',
                        agent1: connectionData.from.mesh,
                        agent2: connectionData.to.mesh,
                        strength: connectionData.opacity,
                        connectionType: connectionData.type || 'architectural',
                        baseColor: connectionData.color,
                        baseOpacity: connectionData.opacity * 1.5,
                        pulsePhase: Math.random() * Math.PI * 2,
                        lightningActive: false
                    };
                    
                    scene.add(line);
                    connections.push({
                        line: line,
                        sourceId: connectionData.from.id,
                        targetId: connectionData.to.id
                    });
                }
            }
            
            // Apply all connection sets
            console.log('üîó Creating primary architectural connections...');
            primaryConnections.forEach(createConnection);
            
            console.log('üîç Creating search agent cluster connections...');
            searchConnections.forEach(createConnection);
            
            console.log('üìä Creating data flow connections...');
            dataFlowConnections.forEach(createConnection);
            
            console.log(`‚úÖ Created ${connections.length} architectural connections`);
        }

        // Initialize WebSocket connection with enhanced handlers
        function initWebSocket() {
            try {
                console.log('üîå Initializing WebSocket connection...');
                // Check if socket.io is available
                if (typeof io !== 'undefined') {
                    socket = io();
                    
                    socket.on('connect', () => {
                        console.log('‚úÖ Connected to server');
                    });
                    
                    socket.on('disconnect', () => {
                        console.log('Disconnected from server');
                    });

                    // Listen for research updates and populate research results
                    socket.on('researchUpdate', (data) => {
                        console.log('üî¨ Research update received:', data);
                        
                        switch (data.type) {
                            case 'perplexity_result':
                                if (!researchResults.perplexityResults) researchResults.perplexityResults = [];
                                researchResults.perplexityResults.push({
                                    query: data.query,
                                    results: data.results,
                                    sources: data.sources || [],
                                    links: data.links || [],
                                    timestamp: data.timestamp,
                                    isDemo: data.isDemo || false
                                });
                                console.log('üìä Added Perplexity results to researchResults');
                                
                                // Show demo mode indicator if applicable
                                if (data.isDemo) {
                                    const status = document.getElementById('researchStatus');
                                    if (status) {
                                        status.innerHTML = `
                                            <div style="color: #ffaa00; padding: 6px; font-size: 9px; opacity: 0.8;">
                                                üéÆ Demo Mode - Real results need API keys
                                            </div>
                                        `;
                                    }
                                }
                                break;
                            case 'agent_analysis':
                                if (!researchResults.agentAnalysis) researchResults.agentAnalysis = [];
                                researchResults.agentAnalysis.push({
                                    agent: data.agent,
                                    analysis: data.analysis,
                                    insights: data.insights || [],
                                    confidence: data.confidence,
                                    timestamp: data.timestamp
                                });
                                console.log('ü§ñ Added agent analysis to researchResults');
                                break;
                            case 'final_summary':
                                researchResults.finalSummary = data.summary;
                                console.log('üìã Added final summary to researchResults');
                                break;
                            case 'completed':
                                researchResults.endTime = Date.now();
                                researchResults.totalResults = data.embeddingCount || 0;
                                console.log('‚úÖ Research completed and data collected');
                                break;
                        }
                    });
                } else {
                    console.log('‚ö†Ô∏è Socket.io not available, continuing without WebSocket');
                }
            } catch (error) {
                console.warn('WebSocket connection failed:', error.message);
            }
        }

        // Missing handler functions
        function handleAnthropicResearchUpdate(data) {
            console.log('üî¨ Research update:', data);
        }
        
        function handleResearchComplete(data) {
            console.log('‚úÖ Research completed:', data);
        }
        
        function handleEnhancedAgentData(data) {
            console.log('ü§ñ Enhanced agent data:', data);
        }
        
        // Add embedding to the main 3D scene with agents - static, no animation
        function addEmbeddingToMainScene(embeddingData) {
            if (!scene) return;

            const position = {
                x: embeddingData.x * 2, // Scale for better visibility
                y: embeddingData.y * 2,
                z: embeddingData.z * 2
            };
            if (position.x === undefined) return;

            // Determine color based on the type of embedding
            const typeColors = {
                'perplexity_search': 0x00aaff, // Blue for Perplexity
                'agent_analysis': 0xffaa00, // Orange for Sub-agent work
                'initial_search': 0xffff00, // Yellow for initial search
                'default': 0xffffff // White for others
            };
            const color = typeColors[embeddingData.metadata?.type] || typeColors['default'];

            // Create a minimal embedding point
            const geometry = new THREE.SphereGeometry(0.2, 12, 12);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8
            });
            const mesh = new THREE.Mesh(geometry, material);
            
            // Set to final position immediately - no animation
            mesh.position.set(position.x, position.y, position.z);
            
            mesh.userData = {
                id: embeddingData.id,
                type: embeddingData.metadata?.type || 'default',
                timestamp: Date.now(),
                staticPosition: position // Store static position
            };

            scene.add(mesh);
            embeddings.push(mesh);
            
            // Create connections to nearest embeddings (k-nearest neighbors)
            createEmbeddingConnections(mesh);
            
            console.log(`‚ú® Added static embedding to main scene: ${embeddingData.id} at position (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)})`);
        }

        // Create connections between embeddings (k-nearest neighbors approach)
        function createEmbeddingConnections(newEmbedding) {
            const maxConnections = 3; // Connect to 3 nearest embeddings
            const maxDistance = 8.0; // Maximum distance for connections
            
            // Find distances to all other embeddings
            const distances = [];
            embeddings.forEach(embedding => {
                if (embedding !== newEmbedding) {
                    const distance = newEmbedding.position.distanceTo(embedding.position);
                    if (distance <= maxDistance) {
                        distances.push({ embedding, distance });
                    }
                }
            });
            
            // Sort by distance and take the closest ones
            distances.sort((a, b) => a.distance - b.distance);
            const nearestEmbeddings = distances.slice(0, maxConnections);
            
            // Create connections to nearest embeddings
            nearestEmbeddings.forEach(({ embedding, distance }) => {
                const points = [
                    newEmbedding.position.clone(),
                    embedding.position.clone()
                ];
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0x44ff88,
                    transparent: true,
                    opacity: 0.4 * (1 - distance / maxDistance), // Fade with distance
                    linewidth: 1
                });
                
                const line = new THREE.Line(geometry, material);
                line.userData = {
                    type: 'embedding_connection',
                    embedding1: newEmbedding,
                    embedding2: embedding,
                    distance: distance
                };
                
                scene.add(line);
                connections.push(line);
            });
        }

        
        // Main animation loop with enhanced particle system
        function animate() {
            requestAnimationFrame(animate);

            // Update controls
            if (controls) {
                controls.update();
            }

            // Animate agent glows and update states
            agents.forEach((agent) => {
                if (agent.mesh && agent.mesh.userData && agent.mesh.userData.glow) {
                    agent.mesh.userData.glow.rotation.z += 0.005;
                    
                    // Dynamic glow based on agent state
                    const state = agentStates.get(agent.mesh.userData.agentId);
                    if (state) {
                        const intensity = 0.3 + (state.workload * 0.4);
                        agent.mesh.userData.glow.material.opacity = intensity;
                    }
                }
            });

            // Minimal connection animations - only during research
            connections.forEach((connection, index) => {
                const line = connection.line;
                if (!line || !line.userData) return;
                
                if (line.userData.type === 'agent_connection' && isResearchActive) {
                    // Very subtle pulsing during research only
                    const time = Date.now() * 0.001;
                    line.userData.pulsePhase += 0.02; // Much slower
                    
                    // Rare, subtle lightning flashes only during active research
                    if (Math.random() < 0.0005) { // Much rarer - 0.05% chance
                        line.userData.lightningActive = true;
                        line.userData.lightningStart = Date.now();
                    }
                    
                    if (line.userData.lightningActive) {
                        const lightningElapsed = Date.now() - line.userData.lightningStart;
                        if (lightningElapsed < 100) { // Shorter lightning
                            // Subtle flash - not too bright
                            const flash = Math.sin(lightningElapsed * 0.08) * 0.3 + 1.0;
                            line.material.opacity = Math.min(0.8, line.userData.baseOpacity * flash);
                            // Keep original color, just brighter
                            const originalColor = new THREE.Color(line.userData.baseColor);
                            line.material.color.copy(originalColor.multiplyScalar(flash));
                        } else {
                            line.userData.lightningActive = false;
                            line.material.color.setHex(line.userData.baseColor);
                        }
                    } else {
                        // Very gentle pulsing
                        const pulse = Math.sin(line.userData.pulsePhase) * 0.1 + 0.9;
                        line.material.opacity = line.userData.baseOpacity * pulse;
                    }
                } else if (!isResearchActive) {
                    // Reset to base state when research is not active
                    line.material.opacity = line.userData.baseOpacity;
                    line.material.color.setHex(line.userData.baseColor);
                }
            });

            // Animate data packets and task flow particles
            animateDataPackets();
            
            // Update agent visual states
            updateAgentVisualStates();

            // Render main scene
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
            
            // Note: Embedding space renders in its own animation loop (animateEmbeddingSpace)
        }
        
        // Animate light effects on connection lines instead of particles
        function animateDataPackets() {
            // Handle legacy dataPackets for backwards compatibility
            dataPackets.forEach((packet, index) => {
                packet.progress += packet.speed;
                
                if (packet.progress >= 1) {
                    scene.remove(packet.mesh);
                    if (packet.mesh.geometry) packet.mesh.geometry.dispose();
                    if (packet.mesh.material) packet.mesh.material.dispose();
                    dataPackets.splice(index, 1);
                    return;
                }
                
                if (packet.startPos && packet.endPos) {
                    packet.mesh.position.lerpVectors(packet.startPos, packet.endPos, packet.progress);
                } else if (packet.curve) {
                    const position = packet.curve.getPoint(packet.progress);
                    packet.mesh.position.copy(position);
                }
                
                packet.mesh.rotation.x += 0.1;
                packet.mesh.rotation.y += 0.05;
                
                const glowIntensity = Math.sin(packet.progress * Math.PI * 2) * 0.3 + 0.7;
                packet.mesh.material.opacity = 0.8 * glowIntensity;
                packet.mesh.scale.setScalar(0.8 + 0.3 * glowIntensity);
            });
            
            // Animate research-aware effects with intelligent coloring - ENHANCED VISIBILITY
            if (window.researchEffects && isResearchActive) {
                window.researchEffects.forEach((effect, index) => {
                    effect.progress += effect.speed * 1.5; // Faster animations for better visibility
                    
                    if (effect.progress >= 1) {
                        // Reset line to original state with gentle fade
                        if (effect.line && effect.line.material) {
                            effect.line.material.opacity = effect.originalOpacity;
                            effect.line.material.color.setHex(effect.originalColor);
                        }
                        window.researchEffects.splice(index, 1);
                        return;
                    }
                    
                    // Create intelligent research flow visualization - ENHANCED
                    if (effect.line && effect.line.material) {
                        // More dramatic directional wave pattern
                        const directionalWave = Math.sin((effect.progress - 0.1) * Math.PI * 2); // Doubled frequency
                        const secondaryPulse = Math.sin(effect.progress * Math.PI * 6) * 0.4; // Stronger pulse
                        const wave = Math.max(0, directionalWave + secondaryPulse);
                        
                        const intensity = effect.intensity * wave * 1.8; // Much stronger intensity
                        
                        // Much more dramatic opacity changes
                        effect.line.material.opacity = Math.min(1.0, effect.originalOpacity + intensity * 1.2);
                        
                        // Research-specific color transitions - more vivid
                        const baseColor = new THREE.Color(effect.originalColor);
                        const researchColor = new THREE.Color(effect.researchColor);
                        
                        // Stronger color blending for better visibility
                        const blendedColor = baseColor.clone().lerp(researchColor, Math.min(1.0, intensity * 1.2));
                        effect.line.material.color.copy(blendedColor);
                        
                        // Enhanced connection glow - much brighter
                        if (intensity > 0.2) { // Lower threshold for activation
                            // Very bright glow using enhanced color intensity
                            const glowColor = researchColor.clone().lerp(new THREE.Color(0xffffff), 0.5);
                            effect.line.material.color.copy(glowColor);
                            effect.line.material.opacity = Math.min(1.0, effect.originalOpacity * 3 * intensity); // Triple intensity
                        } else {
                            // Normal state
                            effect.line.material.opacity = effect.originalOpacity + intensity * 0.5;
                        }
                        
                        // Create research flow indicators at wave peaks
                        if (directionalWave > 0.8 && Math.random() < 0.05) {
                            createResearchFlowIndicator(effect);
                        }
                    }
                });
            }
            
            // Handle legacy minimal effects for backwards compatibility
            if (window.minimalEffects && isResearchActive) {
                window.minimalEffects.forEach((effect, index) => {
                    effect.progress += effect.speed;
                    
                    if (effect.progress >= 1) {
                        // Reset line to original state
                        if (effect.line && effect.line.material) {
                            effect.line.material.opacity = effect.originalOpacity;
                            effect.line.material.color.setHex(effect.originalColor);
                        }
                        window.minimalEffects.splice(index, 1);
                        return;
                    }
                    
                    // Create a subtle traveling wave
                    if (effect.line && effect.line.material) {
                        const wave = Math.sin(effect.progress * Math.PI);
                        const intensity = 0.3 * wave; // Very subtle
                        
                        // Gentle opacity increase
                        effect.line.material.opacity = effect.originalOpacity + intensity * 0.4;
                        
                        // Subtle color shift towards cyan during activity
                        const baseColor = new THREE.Color(effect.originalColor);
                        const activeColor = new THREE.Color(0x00ffff);
                        effect.line.material.color.copy(baseColor.lerp(activeColor, intensity * 0.3));
                    }
                });
            }
        }
        
        // Minimal agent visual states - only show activity during research
        function updateAgentVisualStates() {
            agents.forEach((agent, agentId) => {
                const state = agentStates.get(agentId);
                if (!state || !agent.mesh) return;
                
                const time = Date.now() * 0.001;
                
                // Handle different types of meshes (single mesh vs groups)
                let targetMesh = agent.mesh;
                let material = null;
                
                if (agent.mesh.type === 'Group') {
                    // For groups (database, hammer), find the first mesh child with material
                    agent.mesh.children.forEach(child => {
                        if (child.material && child.material.emissive && !material) {
                            material = child.material;
                            targetMesh = child;
                        }
                    });
                } else if (agent.mesh.material && agent.mesh.material.emissive) {
                    material = agent.mesh.material;
                }
                
                // Only show emissive effects during active research and high workload
                if (material && material.emissive && isResearchActive && state.workload > 0.3) {
                    const activityPulse = Math.sin(time * 1.5) * 0.1 + 0.9;
                    
                    if (state.workload > 0.8) {
                        // High activity - subtle red pulse
                        const intensity = 0.2 * activityPulse * state.workload;
                        material.emissive.setRGB(intensity, 0, 0);
                        material.emissiveIntensity = 0.3;
                    } else if (state.workload > 0.5) {
                        // Medium activity - subtle blue pulse
                        const intensity = 0.15 * activityPulse * state.workload;
                        material.emissive.setRGB(0, intensity * 0.5, intensity);
                        material.emissiveIntensity = 0.2;
                    } else {
                        // Low activity - very subtle green
                        const intensity = 0.1 * activityPulse * state.workload;
                        material.emissive.setRGB(0, intensity, 0);
                        material.emissiveIntensity = 0.1;
                    }
                } else if (material && material.emissive) {
                    // No research active or low workload - no glow
                    material.emissive.setRGB(0, 0, 0);
                    material.emissiveIntensity = 0;
                }
                
                // Very subtle pulse during activity
                if (agent.mesh.userData && agent.mesh.userData.originalScale && isResearchActive && state.workload > 0.2) {
                    const subtlePulse = Math.sin(time * 1.2 + agentId.charCodeAt(agentId.length - 1)) * 0.01 + 0.99;
                    agent.mesh.scale.setScalar(agent.mesh.userData.originalScale * subtlePulse);
                } else if (agent.mesh.userData && agent.mesh.userData.originalScale) {
                    // Return to original scale when not active
                    agent.mesh.scale.setScalar(agent.mesh.userData.originalScale);
                }
                
                // Gradually decay workload over time
                if (state.workload > 0) {
                    state.workload = Math.max(0, state.workload - 0.003);
                }
            });
        }
        
        // Initialize embedding space canvas
        function initEmbeddingSpace() {
            console.log('üåå Initializing embedding space...');
            
            // Get the embedding canvas
            const embeddingCanvas = document.getElementById('embedding-canvas');
            if (!embeddingCanvas) {
                console.error('Embedding canvas not found');
                return;
            }
            
            // Create embedding scene
            embeddingScene = new THREE.Scene();
            embeddingScene.background = new THREE.Color(0x000000); // Dark background
            
            // Create embedding camera (positioned for optimal 3D viewing)
            embeddingCamera = new THREE.PerspectiveCamera(60, 320 / 200, 0.1, 1000);
            embeddingCamera.position.set(16, 12, 22); // Moved higher up to look down at the network
            
            // Create embedding renderer
            embeddingRenderer = new THREE.WebGLRenderer({ 
                canvas: embeddingCanvas,
                antialias: true,
                alpha: true
            });
            embeddingRenderer.setSize(320, 200);
            
            // Minimal lighting - just basic ambient light
            const embeddingAmbientLight = new THREE.AmbientLight(0x404040, 0.4);
            embeddingScene.add(embeddingAmbientLight);
            
            // Start embedding space animation
            animateEmbeddingSpace();
            
            console.log('‚úÖ Embedding space initialized');
        }
        
        // Animate the embedding space with enhanced 3D effects
        function animateEmbeddingSpace() {
            embeddingAnimationId = requestAnimationFrame(animateEmbeddingSpace);
            
            if (!embeddingRenderer || !embeddingScene || !embeddingCamera) {
                return;
            }
            
            const time = Date.now() * 0.001;
            
            // Animate embedding points with minimal 3D movement
            embeddingPoints.forEach((point, index) => {
                if (point && point.userData) {
                    // Subtle rotation
                    point.rotation.x = time * 0.2 + index * 0.1;
                    point.rotation.y = time * 0.15 + index * 0.08;
                    point.rotation.z = time * 0.1 + index * 0.05;
                    
                    // Very subtle scale pulsing
                    const sizePulse = 1 + Math.sin(time * 1.5 + (point.position.x + point.position.z) * 0.5) * 0.1;
                    point.scale.setScalar(sizePulse);
                    
                    // Pulsing opacity
                    if (point.material) {
                        point.material.opacity = 0.6 + 0.4 * Math.sin(time + index * 0.3);
                    }
                }
            });
            
            // Animate embedding connections with pulse effect
            embeddingConnections.forEach((connection, index) => {
                if (connection && connection.material) {
                    const phase = (time * 1.2 + index * 0.2) % (Math.PI * 2);
                    const pulse = 0.15 + Math.sin(phase) * 0.15; // Enhanced pulsing
                    connection.material.opacity = Math.max(0.1, pulse);
                    
                    // Enhanced connection flow animation
                    if (connection.userData && connection.userData.pulsePhase !== undefined) {
                        connection.userData.pulsePhase += 0.08;
                        const flowPulse = Math.sin(connection.userData.pulsePhase);
                        const enhancement = 0.5 + 0.5 * flowPulse;
                        connection.material.opacity = pulse * enhancement;
                        
                        // Add subtle color shifts
                        const colorShift = Math.sin(time * 0.5 + index * 0.8) * 0.1;
                        const originalColor = connection.userData.color;
                        if (originalColor && connection.material.color) {
                            const r = ((originalColor >> 16) & 255) / 255;
                            const g = ((originalColor >> 8) & 255) / 255;
                            const b = (originalColor & 255) / 255;
                            connection.material.color.setRGB(
                                Math.max(0, Math.min(1, r + colorShift)),
                                Math.max(0, Math.min(1, g + colorShift)),
                                Math.max(0, Math.min(1, b + colorShift))
                            );
                        }
                    }
                }
            });
            
            // Dynamic 3D camera movement (zoomed out and centered)
            const cameraRadius = 22;
            const cameraHeight = 8;
            embeddingCamera.position.x = Math.sin(time * 0.15) * cameraRadius;
            embeddingCamera.position.z = Math.cos(time * 0.15) * cameraRadius;
            embeddingCamera.position.y = cameraHeight + Math.sin(time * 0.1) * 2;
            
            // Camera looks at the center of the network
            const lookAtX = Math.sin(time * 0.05) * 1;
            const lookAtY = Math.cos(time * 0.08) * 0.5 - 2;
            embeddingCamera.lookAt(lookAtX, lookAtY, 0);
            
            // Render embedding scene
            try {
                embeddingRenderer.render(embeddingScene, embeddingCamera);
            } catch (error) {
                console.error('Error rendering embedding space:', error);
            }
        }
        
        // Visualize task flow between agents (removed - duplicate function)
        
        // Intelligent task flow visualization - glows connections based on research logic
        function visualizeTaskFlow(sourceAgentId, targetAgentId) {
            // Only trigger effects if research is active
            if (!isResearchActive) {
                console.log(`‚è∏Ô∏è Skipping task flow visualization - research not active`);
                return;
            }

            const sourceAgent = agents.get(sourceAgentId);
            const targetAgent = agents.get(targetAgentId);

            if (!sourceAgent || !targetAgent) {
                console.warn(`‚ùå visualizeTaskFlow: Missing agents - source: ${!!sourceAgent}, target: ${!!targetAgent}`);
                return;
            }

            // Find existing connection line between these agents
            let connectionLine = null;
            connections.forEach(conn => {
                if ((conn.sourceId === sourceAgentId && conn.targetId === targetAgentId) ||
                    (conn.sourceId === targetAgentId && conn.targetId === sourceAgentId)) {
                    connectionLine = conn.line;
                }
            });

            if (connectionLine) {
                // Determine the type of research interaction for intelligent coloring
                const interactionType = getResearchInteractionType(sourceAgentId, targetAgentId);
                
                // Create a research-aware traveling pulse along the connection line
                const pulseEffect = {
                    line: connectionLine,
                    progress: 0,
                    speed: interactionType.speed,
                    startTime: Date.now(),
                    sourceId: sourceAgentId,
                    targetId: targetAgentId,
                    originalOpacity: connectionLine.material.opacity,
                    originalColor: connectionLine.userData.baseColor,
                    researchColor: interactionType.color,
                    researchType: interactionType.type,
                    intensity: interactionType.intensity
                };
                
                // Add to research-aware effects array
                if (!window.researchEffects) window.researchEffects = [];
                window.researchEffects.push(pulseEffect);
                
                console.log(`üî¨ ${interactionType.type} flow: ${sourceAgentId} ‚Üí ${targetAgentId}`);
            }
            
            // Minimal agent state updates
            const sourceState = agentStates.get(sourceAgentId);
            const targetState = agentStates.get(targetAgentId);
            
            if (sourceState) {
                sourceState.workload = Math.min(1, sourceState.workload + 0.1);
                sourceState.lastActivity = Date.now();
            }
            if (targetState) {
                targetState.workload = Math.min(1, targetState.workload + 0.05);
            }
            
            console.log(`üí´ Research flow from ${sourceAgentId} to ${targetAgentId}`);
        }

        // Determine the type of research interaction for intelligent visualization
        function getResearchInteractionType(sourceId, targetId) {
            const sourceAgent = agents.get(sourceId);
            const targetAgent = agents.get(targetId);
            
            if (!sourceAgent || !targetAgent) return { type: 'unknown', color: 0x666666, speed: 0.03, intensity: 0.3 };
            
            const sourceType = sourceAgent.mesh.userData?.specialization || 'unknown';
            const targetType = targetAgent.mesh.userData?.specialization || 'unknown';
            
            // Research orchestration flows
            if (sourceType === 'orchestration') {
                if (targetType === 'search') return { 
                    type: 'Query Distribution', 
                    color: 0x00aaff, 
                    speed: 0.04, 
                    intensity: 0.6 
                };
                if (targetType === 'database') return { 
                    type: 'Context Retrieval', 
                    color: 0x8800ff, 
                    speed: 0.035, 
                    intensity: 0.5 
                };
                if (targetType === 'tools') return { 
                    type: 'Tool Activation', 
                    color: 0xff8800, 
                    speed: 0.045, 
                    intensity: 0.5 
                };
            }
            
            // Search to analysis flows
            if (sourceType === 'search' && targetType === 'citations') return {
                type: 'Source Validation',
                color: 0xff0088,
                speed: 0.03,
                intensity: 0.4
            };
            
            // Analysis and synthesis flows
            if (sourceType === 'citations' && targetType === 'synthesis') return {
                type: 'Knowledge Integration',
                color: 0x88ff00,
                speed: 0.025,
                intensity: 0.7
            };
            
            // Memory storage flows
            };
            
            // Inter-search collaboration
            if (sourceType === 'search' && targetType === 'search') return {
                type: 'Search Coordination',
                color: 0x44aaff,
                speed: 0.05,
                intensity: 0.3
            };
            
            // Synthesis feedback loops
            if (sourceType === 'synthesis') return {
                type: 'Result Synthesis',
                color: 0xaaff44,
                speed: 0.03,
                intensity: 0.5
            };
            
            // Default research flow
            return { 
                type: 'Information Flow', 
                color: 0x44ffaa, 
                speed: 0.03, 
                intensity: 0.3 
            };
        }
        
        // User research functions
        function startUserResearch() {
            const input = document.getElementById('researchTopic');
            if (!input || !input.value.trim()) {
                const status = document.getElementById('researchStatus');
                if (status) status.textContent = 'Please enter a research topic';
                return;
            }
            
            const topic = input.value.trim();
            console.log('üîç Starting enhanced research for topic:', topic);
            
            // Clear previous research first
            clearResearchVisualizations();
            
            // Set research as active and initialize tracking
            isResearchActive = true;
            researchStartTime = Date.now();
            researchTopic = topic;
            totalInteractions = 0;
            
            // Initialize research results
            researchResults = {...RESEARCH_RESULTS_TEMPLATE};
            researchResults.startTime = researchStartTime;
            researchResults.topic = topic;
            researchResults.embeddingPoints = [];
            researchResults.connections = [];
            researchResults.agentInteractions = [];
            
            console.log('‚úÖ Research set as active:', isResearchActive);
            
            // Update status
            const status = document.getElementById('researchStatus');
            if (status) {
                status.innerHTML = `
                    <div style="color: #ffffff; padding: 6px; font-size: 9px; opacity: 0.7;">
                        Researching: ${topic}...
                    </div>
                `;
            }
            
            // Start enhanced agent interactions simulation
            console.log('üé¨ Starting enhanced embedding simulation...');
            simulateEnhancedAgentInteractions();
            
            // Emit to server if socket is available
            if (socket && socket.connected) {
                socket.emit('startResearch', { 
                    topic: topic,
                    architecture: 'anthropic_research_system'
                });
                console.log('üì° Sent multi-agent research request:', topic);
            } else {
                console.warn('WebSocket not connected - running visualization only');
            }
            
            // Simulate research completion after extended duration
            setTimeout(() => {
                if (isResearchActive) {
                    // PROPERLY STOP THE RESEARCH
                    isResearchActive = false; // This stops all interactions
                    researchResults.endTime = Date.now();
                    if (status) {
                        status.innerHTML = `
                            <div style="color: #00ff88; padding: 6px; font-size: 9px; opacity: 0.7;">
                                Research Complete! ${embeddingPoints.length} insights found.
                            </div>
                        `;
                    }
                    console.log(`üìä Research completed: ${embeddingPoints.length} points, ${embeddingConnections.length} connections`);
                    console.log('üõë Research interactions stopped');
                }
            }, 35000); // Extended to 35 seconds for complex visualization
        }
        
        function clearResearchVisualizations() {
            console.log('üßπ Clearing research visualizations');
            
            // Stop research activity
            isResearchActive = false;
            
            // Clear embeddings from main scene
            embeddings.forEach(embedding => {
                scene.remove(embedding);
                if (embedding.geometry) embedding.geometry.dispose();
                if (embedding.material) embedding.material.dispose();
            });
            embeddings = [];
            
            // Clear embedding space points
            embeddingPoints.forEach(point => {
                if (embeddingScene) embeddingScene.remove(point);
                if (point.geometry) point.geometry.dispose();
                if (point.material) point.material.dispose();
            });
            embeddingPoints = [];
            
            // Clear embedding space connections
            embeddingConnections.forEach(connection => {
                if (embeddingScene) embeddingScene.remove(connection);
                if (connection.geometry) connection.geometry.dispose();
                if (connection.material) connection.material.dispose();
            });
            embeddingConnections = [];
            
            // Clear research-aware effects
            if (window.researchEffects) {
                window.researchEffects.forEach(effect => {
                    if (effect.line && effect.line.material) {
                        effect.line.material.opacity = effect.originalOpacity;
                        effect.line.material.color.setHex(effect.originalColor);
                        // Removed emissive code - LineBasicMaterial doesn't support emissive
                    }
                });
                window.researchEffects = [];
            }
            
            // Clear minimal effects
            if (window.minimalEffects) {
                window.minimalEffects.forEach(effect => {
                    if (effect.line && effect.line.material) {
                        effect.line.material.opacity = effect.originalOpacity;
                        effect.line.material.color.setHex(effect.originalColor);
                    }
                });
                window.minimalEffects = [];
            }
            
            // Clear legacy light effects
            if (window.lightEffects) {
                window.lightEffects = [];
            }
            
            // Clear legacy particles (for backwards compatibility)
            particles.forEach(particle => {
                scene.remove(particle.mesh);
                if (particle.mesh.geometry) particle.mesh.geometry.dispose();
                if (particle.mesh.material) particle.mesh.material.dispose();
            });
            particles = [];
            
            dataPackets.forEach(packet => {
                scene.remove(packet.mesh);
                if (packet.mesh.geometry) packet.mesh.geometry.dispose();
                if (packet.mesh.material) packet.mesh.material.dispose();
            });
            dataPackets = [];
            
            // Reset counters
            totalInteractions = 0;
            researchStartTime = 0;
            researchTopic = '';
            
            // Clear research status
            const status = document.getElementById('researchStatus');
            if (status) {
                status.innerHTML = '';
            }
            
            console.log('üßπ Research space cleared - embeddings start from zero');
        }
        
        function exportResearchResults() {
            console.log('üìÑ Displaying collected research results');
            
            if (!researchResults.topic) {
                alert('No research results to export. Please run a search first.');
                return;
            }

            // Debug: Check what data we actually have
            console.log('üîç Debug - researchResults:', researchResults);
            console.log('üîç Debug - perplexityResults:', researchResults.perplexityResults);
            console.log('üîç Debug - agentAnalysis:', researchResults.agentAnalysis);

            // Create simple, minimal export data
            const exportData = {
                topic: researchResults.topic,
                duration: researchResults.endTime ? ((researchResults.endTime - researchResults.startTime) / 1000).toFixed(1) : 'N/A',
                results: 'No search results available yet. This appears to be a visualization-only session.',
                sources: [],
                links: [],
                analyses: [],
                completedAt: new Date().toLocaleString()
            };

            // Try to get real data if available
            if (researchResults.perplexityResults && researchResults.perplexityResults.length > 0) {
                const result = researchResults.perplexityResults[0];
                exportData.results = result.results || 'No results text';
                exportData.sources = result.sources || [];
                exportData.links = result.links || [];
            }

            if (researchResults.agentAnalysis && researchResults.agentAnalysis.length > 0) {
                exportData.analyses = researchResults.agentAnalysis.map(analysis => ({
                    agent: analysis.agent,
                    text: analysis.analysis
                }));
            }
            
            // Create results overlay with collected data
            const overlay = createResearchResultsOverlay(exportData);
            document.body.appendChild(overlay);
            
            console.log('‚úÖ Research results displayed from collected data');
        }

        // Fetch real research data from the server
        async function fetchRealResearchData(topic) {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('Research request timeout'));
                }, 30000);

                // Listen for research results
                let searchResults = null;
                let agentAnalyses = [];
                let finalSummary = null;

                const handleResearchUpdate = (data) => {
                    console.log('üîç Research update received:', data);
                    
                    switch (data.type) {
                        case 'perplexity_result':
                            searchResults = data;
                            break;
                        case 'agent_analysis':
                            agentAnalyses.push(data);
                            break;
                        case 'final_summary':
                            finalSummary = data;
                            break;
                        case 'completed':
                            clearTimeout(timeout);
                            socket.off('researchUpdate', handleResearchUpdate);
                            
                            resolve({
                                topic: topic,
                                searchResults: searchResults,
                                agentAnalyses: agentAnalyses,
                                finalSummary: finalSummary,
                                embeddingCount: data.embeddingCount || 0,
                                completedAt: new Date().toISOString(),
                                duration: ((Date.now() - researchResults.startTime) / 1000).toFixed(1)
                            });
                            break;
                        case 'error':
                            clearTimeout(timeout);
                            socket.off('researchUpdate', handleResearchUpdate);
                            reject(new Error(data.message));
                            break;
                    }
                };

                socket.on('researchUpdate', handleResearchUpdate);
                
                // Trigger new research session
                socket.emit('startResearch', {
                    topic: topic,
                    usePerplexitySearch: true,
                    useGPTOrchestration: true
                });
            });
        }

        // Create loading overlay
        function createLoadingOverlay() {
            const overlay = document.createElement('div');
            overlay.id = 'loading-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.95);
                color: #ffffff;
                z-index: 1000;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                font-family: 'Segoe UI', sans-serif;
            `;
            
            overlay.innerHTML = `
                <div style="text-align: center;">
                    <div style="width: 60px; height: 60px; border: 3px solid #333; border-top: 3px solid #00ff88; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;"></div>
                    <h2 style="color: #00ff88; margin-bottom: 10px;">Fetching Research Results</h2>
                    <p style="color: #ccc; margin: 0;">Querying APIs and analyzing data...</p>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;
            
            return overlay;
        }

        // Create research results overlay with real data
        function createResearchResultsOverlay(data) {
            const overlay = document.createElement('div');
            overlay.id = 'results-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.95);
                color: #cccccc;
                z-index: 1000;
                padding: 40px;
                box-sizing: border-box;
                overflow-y: auto;
                font-family: 'Segoe UI', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            `;
            
            // Create minimal, clean content
            const hasResults = data.sources.length > 0 || data.links.length > 0 || data.analyses.length > 0;
            
            overlay.innerHTML = `
                <div style="max-width: 800px; margin: 0 auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; border-bottom: 1px solid #333; padding-bottom: 15px;">
                        <h1 style="color: #ffffff; font-size: 20px; margin: 0; font-weight: 400;">${data.topic}</h1>
                        <button onclick="document.getElementById('results-overlay').remove()" 
                                style="background: #666; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                            Close
                        </button>
                    </div>
                    
                    <div style="margin-bottom: 20px; color: #999; font-size: 12px;">
                        Duration: ${data.duration} | Completed: ${data.completedAt}
                    </div>
                    
                    ${!hasResults ? `
                    <div style="background: #222; padding: 20px; border-radius: 4px; margin-bottom: 20px; border-left: 3px solid #666;">
                        <div style="font-size: 13px; color: #aaa; margin-bottom: 10px;">Status:</div>
                        <div style="color: #ccc;">This was a visualization-only session. No external API results were collected.</div>
                    </div>
                    ` : ''}
                    
                    ${data.results !== 'No search results available yet. This appears to be a visualization-only session.' ? `
                    <div style="background: #1a1a1a; padding: 20px; border-radius: 4px; margin-bottom: 20px; border-left: 3px solid #555;">
                        <div style="font-size: 13px; color: #aaa; margin-bottom: 10px; text-transform: uppercase;">Results:</div>
                        <div style="color: #ddd; white-space: pre-line;">${data.results}</div>
                    </div>
                    ` : ''}
                    
                    ${data.sources.length > 0 ? `
                    <div style="background: #1a1a1a; padding: 20px; border-radius: 4px; margin-bottom: 20px; border-left: 3px solid #555;">
                        <div style="font-size: 13px; color: #aaa; margin-bottom: 10px; text-transform: uppercase;">Sources (${data.sources.length}):</div>
                        ${data.sources.map(source => `<div style="color: #ccc; margin-bottom: 5px;">‚Ä¢ ${source}</div>`).join('')}
                    </div>
                    ` : ''}
                    
                    ${data.links.length > 0 ? `
                    <div style="background: #1a1a1a; padding: 20px; border-radius: 4px; margin-bottom: 20px; border-left: 3px solid #555;">
                        <div style="font-size: 13px; color: #aaa; margin-bottom: 10px; text-transform: uppercase;">Links (${data.links.length}):</div>
                        ${data.links.map(link => `
                            <div style="margin-bottom: 8px;">
                                <a href="${link}" target="_blank" style="color: #888; text-decoration: none; font-size: 12px;">
                                    ${link.length > 60 ? link.substring(0, 60) + '...' : link}
                                </a>
                            </div>
                        `).join('')}
                    </div>
                    ` : ''}
                    
                    ${data.analyses.length > 0 ? `
                    <div style="background: #1a1a1a; padding: 20px; border-radius: 4px; margin-bottom: 20px; border-left: 3px solid #555;">
                        <div style="font-size: 13px; color: #aaa; margin-bottom: 10px; text-transform: uppercase;">Agent Analysis (${data.analyses.length}):</div>
                        ${data.analyses.map(analysis => `
                            <div style="margin-bottom: 15px;">
                                <div style="color: #999; font-size: 12px; margin-bottom: 5px;">${analysis.agent}:</div>
                                <div style="color: #ccc; font-size: 13px; padding-left: 10px;">${analysis.text}</div>
                            </div>
                        `).join('')}
                    </div>
                    ` : ''}
                    
                    <div style="text-align: center; margin-top: 30px;">
                        <button onclick="copyResultsToClipboard('${data.topic.replace(/'/g, "\\'")}', '${data.results.replace(/'/g, "\\'").replace(/\n/g, "\\n")}', ${JSON.stringify(data.sources)}, ${JSON.stringify(data.links)})" 
                                style="background: #444; color: #ccc; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                            Copy Results
                        </button>
                    </div>
                </div>
            `;
            
            return overlay;
        }

        // Copy research results to clipboard
        function copyResearchResults(data) {
            const textContent = `
Research Results: ${data.topic}
Duration: ${data.duration}s
Completed: ${new Date(data.completedAt).toLocaleString()}

${data.searchResults ? `
SEARCH RESULTS:
${data.searchResults.results}

SOURCES:
${data.searchResults.sources?.join('\n') || 'None'}

LINKS:
${data.searchResults.links?.join('\n') || 'None'}
` : ''}

${data.agentAnalyses.length > 0 ? `
AGENT ANALYSIS:
${data.agentAnalyses.map(analysis => `
${analysis.agent}: ${analysis.analysis}
Confidence: ${Math.round((analysis.confidence || 0.75) * 100)}%
${analysis.insights ? 'Insights: ' + analysis.insights.join('; ') : ''}
`).join('\n')}
` : ''}

${data.finalSummary ? `
SUMMARY:
${data.finalSummary.summary}
` : ''}
            `.trim();
            
            navigator.clipboard.writeText(textContent).then(() => {
                alert('Research results copied to clipboard!');
            }).catch(() => {
                alert('Failed to copy to clipboard');
            });
        }

        // Download research results as JSON
        function downloadResearchResults(data) {
            const jsonBlob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(jsonBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `research-results-${data.topic.replace(/[^a-zA-Z0-9]/g, '-')}-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Simple copy function for minimal results
        function copyResultsToClipboard(topic, results, sources, links) {
            const text = `Research: ${topic}

Results:
${results}

Sources:
${sources.join('\n')}

Links:
${links.join('\n')}`;
            
            navigator.clipboard.writeText(text).then(() => {
                alert('Results copied to clipboard');
            }).catch(() => {
                alert('Copy failed');
            });
        }

        window.copyResultsToClipboard = copyResultsToClipboard;

        // Show architecture information
        function showArchitectureInfo() {
            alert(`üéØ Lead Orchestrator: Main research coordinator
üß† Memory Database: Persistent storage and context
üîß Tools Database: API and tool management  
üîç Search Agents (3): Parallel information retrieval
‚úÖ Citations Agent: Source verification
üî¨ Synthesis Agent: Data analysis and insights

The system uses enhanced agent interactions with:
‚Ä¢ Dynamic timing and natural delays
‚Ä¢ Animated data packets between agents
‚Ä¢ Visual state indicators (idle/working/busy)
‚Ä¢ Realistic workflow progression

Click 'Search' to see the agents in action!`);
        }
        
        // Remove the excessive glow function - replaced with minimal approach
        // All visual effects are now handled in updateAgentVisualStates() and visualizeTaskFlow()
        
        // Make functions globally available on window object
        window.startUserResearch = startUserResearch;
        window.clearResearchVisualizations = clearResearchVisualizations;
        window.exportResearchResults = exportResearchResults;
        window.copyResearchResults = copyResearchResults;
        window.downloadResearchResults = downloadResearchResults;
        window.showArchitectureInfo = showArchitectureInfo;
        window.addEmbeddingPoint = addEmbeddingPoint;
        window.simulateEnhancedAgentInteractions = simulateEnhancedAgentInteractions;
        window.visualizeTaskFlow = visualizeTaskFlow;

        // Initialize application when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üåê DOM fully loaded and parsed');
            
            // Give a moment for scripts to settle, then try to initialize
            setTimeout(() => {
                try {
                    init();
                } catch (error) {
                    console.error('‚ùå Failed to initialize application:', error);
                    
                    // Show error message
                    const loading = document.getElementById('loading');
                    const errorMsg = document.getElementById('error-message');
                    if (loading) loading.style.display = 'none';
                    if (errorMsg) errorMsg.style.display = 'block';
                }
            }, 1000);
        });
        
        // Window resize handler
        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        // Add event listeners
        window.addEventListener('resize', onWindowResize, false);
        
        // Add embedding point to embedding space with full 3D positioning  
        function addEmbeddingPoint(data) {
            console.log('üåü addEmbeddingPoint called with:', data, 'isResearchActive:', isResearchActive, 'embeddingScene exists:', !!embeddingScene);
            
            if (!embeddingScene) {
                console.error('‚ùå Embedding scene not available');
                return;
            }
            
            if (!isResearchActive) {
                console.log('‚è∏Ô∏è Research not active, skipping embedding point');
                return;
            }
            
            console.log('üåü Adding 3D embedding point to embedding space:', data);
            
            // Create 3D position in embedding space with better centered distribution
            const radius = 2.5 + Math.random() * 6;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            
            const position = {
                x: radius * Math.sin(phi) * Math.cos(theta),
                y: radius * Math.cos(phi) * 0.9 - 2,
                z: radius * Math.sin(phi) * Math.sin(theta)
            };
            
            // Agent-based color system
            const agentColors = {
                'lead_researcher': 0x00ff88,    // Bright green
                'search_agent': 0x0099ff,       // Bright blue
                'analysis_agent': 0xff6600,     // Bright orange
                'synthesis_agent': 0xaa00ff,    // Bright purple
                'citation_agent': 0xff0099,     // Bright pink
                'memory_agent': 0xff3300,       // Bright red
                'validation_agent': 0x00ffff,   // Cyan
                'context_agent': 0xffff00,      // Yellow
                'pattern_agent': 0xff9900,      // Amber
                'reasoning_agent': 0x9900ff     // Violet
            };
            
            // Create different shapes for different agent types
            let geometry;
            const initialSize = data.isInitial ? 0.1 : 0.15 + Math.random() * 0.1;
            
            switch(data.agentType) {
                case 'lead_researcher':
                    geometry = new THREE.OctahedronGeometry(initialSize, 0);
                    break;
                case 'search_agent':
                    geometry = new THREE.SphereGeometry(initialSize, 8, 6);
                    break;
                case 'analysis_agent':
                    geometry = new THREE.BoxGeometry(initialSize * 1.5, initialSize * 1.5, initialSize * 1.5);
                    break;
                case 'synthesis_agent':
                    geometry = new THREE.ConeGeometry(initialSize, initialSize * 2, 6);
                    break;
                case 'citation_agent':
                    geometry = new THREE.TetrahedronGeometry(initialSize, 0);
                    break;
                case 'memory_agent':
                    geometry = new THREE.CylinderGeometry(initialSize, initialSize, initialSize * 2, 8);
                    break;
                case 'validation_agent':
                    geometry = new THREE.DodecahedronGeometry(initialSize, 0);
                    break;
                case 'context_agent':
                    geometry = new THREE.IcosahedronGeometry(initialSize, 0);
                    break;
                case 'pattern_agent':
                    geometry = new THREE.RingGeometry(initialSize * 0.5, initialSize * 1.2, 8);
                    break;
                case 'reasoning_agent':
                    geometry = new THREE.OctahedronGeometry(initialSize * 1.1, 1);
                    break;
                default:
                    geometry = new THREE.SphereGeometry(initialSize, 6, 6);
            }
            
            const color = agentColors[data.agentType] || 0xffffff;
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8,
                emissive: new THREE.Color(color).multiplyScalar(0.2)
            });
            
            const newPoint = new THREE.Mesh(geometry, material);
            newPoint.position.set(position.x, position.y, position.z);
            
            // Store metadata
            newPoint.userData = {
                agentType: data.agentType,
                color: color,
                timestamp: Date.now() - researchStartTime,
                connections: [],
                isInitial: data.isInitial || false
            };
            
            embeddingScene.add(newPoint);
            embeddingPoints.push(newPoint);
            
            // Record for export
            researchResults.embeddingPoints.push({
                id: embeddingPoints.length,
                agentType: data.agentType,
                position: position,
                color: color,
                timestamp: Date.now() - researchStartTime
            });
            
            // Create connections to nearby points
            const maxDistance = 12;
            const maxConnections = 4;
            let connectionCount = 0;
            
            embeddingPoints.forEach(point => {
                if (point === newPoint || connectionCount >= maxConnections) return;
                
                const distance = newPoint.position.distanceTo(point.position);
                if (distance < maxDistance && distance > 1.5) {
                    const connectionColor = new THREE.Color().lerpColors(
                        new THREE.Color(newPoint.userData.color),
                        new THREE.Color(point.userData.color),
                        0.5
                    );
                    
                    const points = [newPoint.position, point.position];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({
                        color: connectionColor,
                        transparent: true,
                        opacity: 0.3 * (1 - distance / maxDistance),
                        linewidth: 0.5
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    line.userData = {
                        type: 'embedding_space_connection',
                        point1: newPoint,
                        point2: point,
                        distance: distance,
                        color: connectionColor,
                        sendingAgent: newPoint.userData.agentType,
                        receivingAgent: point.userData.agentType,
                        pulsePhase: Math.random() * Math.PI * 2
                    };
                    
                    embeddingScene.add(line);
                    embeddingConnections.push(line);
                    connectionCount++;
                    
                    // Record for export
                    if (!researchResults.connections) {
                        researchResults.connections = [];
                    }
                    researchResults.connections.push({
                        id: embeddingConnections.length,
                        from: newPoint.userData.agentType,
                        to: point.userData.agentType,
                        color: connectionColor.getHex(),
                        distance: distance,
                        timestamp: Date.now() - researchStartTime
                    });
                    
                    totalInteractions++;
                }
            });
            
            console.log(`‚úÖ Added ${data.agentType} embedding point at`, position);
        }
        
        // Simulate enhanced agent interactions for embedding space visualization
        function simulateEnhancedAgentInteractions() {
            console.log('üé≠ simulateEnhancedAgentInteractions called, isResearchActive:', isResearchActive);
            
            if (!isResearchActive) {
                console.log('‚ùå Research not active in simulateEnhancedAgentInteractions');
                return;
            }
            
            console.log('‚úÖ Enhanced simulation starting - research is active');
            
            // Phase 1: Start with lead researcher (small green dot)
            setTimeout(() => {
                if (isResearchActive) {
                    console.log('üü¢ Adding lead researcher point');

                    addEmbeddingPoint({ agentType: 'lead_researcher', isInitial: true });
                    
                    // Create initial task flows in main scene
                    const leadAgent = agents.get('agent_0'); // Lead Orchestrator
                    const memoryAgent = agents.get('agent_1'); // Memory System
                    if (leadAgent && memoryAgent) {
                        visualizeTaskFlow('agent_0', 'agent_1');
                    }
                }
            }, 100);
            
            // Phase 2: Multi-agent search initiation (enhanced complexity)
            const initiateSearchPhase = () => {
                setTimeout(() => {
                    if (isResearchActive) {
                        addEmbeddingPoint({ agentType: 'search_agent' });
                        addEmbeddingPoint({ agentType: 'data_extraction_agent' });
                        visualizeTaskFlow('agent_0', 'agent_3'); // Lead to Search Alpha
                        visualizeTaskFlow('agent_0', 'agent_2'); // Lead to Tool Agent for data prep
                    }
                }, 200);
                
                setTimeout(() => {
                    if (isResearchActive) {
                        addEmbeddingPoint({ agentType: 'search_agent' });
                        addEmbeddingPoint({ agentType: 'source_verification_agent' });
                        visualizeTaskFlow('agent_0', 'agent_4'); // Lead to Search Beta
                        visualizeTaskFlow('agent_2', 'agent_4'); // Tool to Search Beta
                    }
                }, 300);
                
                setTimeout(() => {
                    if (isResearchActive) {
                        addEmbeddingPoint({ agentType: 'search_agent' });
                        addEmbeddingPoint({ agentType: 'concept_mapping_agent' });
                        visualizeTaskFlow('agent_0', 'agent_5'); // Lead to Search Gamma
                        visualizeTaskFlow('agent_1', 'agent_5'); // Memory to Search Gamma (context)
                    }
                }, 400);
            };
            
            initiateSearchPhase();
            
            // Phase 3: Parallel analysis phase (enhanced complexity)
            const initiateAnalysisPhase = () => {
                setTimeout(() => {
                    if (isResearchActive) {
                        addEmbeddingPoint({ agentType: 'analysis_agent' });
                        addEmbeddingPoint({ agentType: 'factcheck_agent' });
                        visualizeTaskFlow('agent_3', 'agent_6'); // Search Alpha to Citations
                        visualizeTaskFlow('agent_3', 'agent_1'); // Search Alpha to Memory (data storage)
                    }
                }, 500);
                
                setTimeout(() => {
                    if (isResearchActive) {
                        addEmbeddingPoint({ agentType: 'citation_agent' });
                        addEmbeddingPoint({ agentType: 'trend_analysis_agent' });
                        visualizeTaskFlow('agent_4', 'agent_6'); // Search Beta to Citations
                        visualizeTaskFlow('agent_4', 'agent_7'); // Search Beta directly to Synthesis (fast path)
                    }
                }, 600);
                
                setTimeout(() => {
                    if (isResearchActive) {
                        addEmbeddingPoint({ agentType: 'analysis_agent' });
                        addEmbeddingPoint({ agentType: 'pattern_agent' });
                        visualizeTaskFlow('agent_5', 'agent_6'); // Search Gamma to Citations
                        // Cross-validation between search agents
                        visualizeTaskFlow('agent_3', 'agent_4');
                        visualizeTaskFlow('agent_4', 'agent_5');
                    }
                }, 700);
            };
            
            initiateAnalysisPhase();
            
            // Phase 4: Complex synthesis and integration
            const initiateSynthesisPhase = () => {
                setTimeout(() => {
                    if (isResearchActive) {
                        addEmbeddingPoint({ agentType: 'synthesis_agent' });
                        addEmbeddingPoint({ agentType: 'reasoning_agent' });
                        // Multiple sources feeding synthesis
                        visualizeTaskFlow('agent_6', 'agent_7'); // Citations to Synthesis
                        visualizeTaskFlow('agent_1', 'agent_7'); // Memory to Synthesis (context integration)
                    }
                }, 800);
                
                setTimeout(() => {
                    if (isResearchActive) {
                        addEmbeddingPoint({ agentType: 'pattern_agent' });
                        addEmbeddingPoint({ agentType: 'context_agent' });
                        // Bi-directional synthesis flows
                        visualizeTaskFlow('agent_7', 'agent_1'); // Synthesis to Memory
                        visualizeTaskFlow('agent_7', 'agent_0'); // Synthesis to Lead
                        visualizeTaskFlow('agent_0', 'agent_7'); // Lead feedback to Synthesis
                    }
                }, 900);
                
                setTimeout(() => {
                    if (isResearchActive) {
                        addEmbeddingPoint({ agentType: 'synthesis_agent' });
                        addEmbeddingPoint({ agentType: 'validation_agent' });
                        // Memory integration cycle
                        visualizeTaskFlow('agent_1', 'agent_0'); // Memory to Lead
                        visualizeTaskFlow('agent_0', 'agent_1'); // Lead to Memory (result storage)
                    }
                }, 1000);
            };
            
            initiateSynthesisPhase();
            
            // Phase 5: Advanced validation and cross-referencing
            const initiateValidationPhase = () => {
                setTimeout(() => {
                    if (isResearchActive) {
                        addEmbeddingPoint({ agentType: 'validation_agent' });
                        addEmbeddingPoint({ agentType: 'source_verification_agent' });
                        // Tool agent assists with validation
                        visualizeTaskFlow('agent_2', 'agent_3'); // Tool to Search (data validation)
                        visualizeTaskFlow('agent_2', 'agent_6'); // Tool to Citations (source checking)
                    }
                }, 1100);
                
                setTimeout(() => {
                    if (isResearchActive) {
                        addEmbeddingPoint({ agentType: 'context_agent' });
                        addEmbeddingPoint({ agentType: 'concept_mapping_agent' });
                        // Multi-directional validation
                        visualizeTaskFlow('agent_7', 'agent_0'); // Synthesis to Lead
                        visualizeTaskFlow('agent_6', 'agent_0'); // Citations to Lead (direct reporting)
                        visualizeTaskFlow('agent_1', 'agent_6'); // Memory to Citations (fact checking)
                    }
                }, 1200);
                
                setTimeout(() => {
                    if (isResearchActive) {
                        addEmbeddingPoint({ agentType: 'validation_agent' });
                        addEmbeddingPoint({ agentType: 'reasoning_agent' });
                        // Feedback loops
                        visualizeTaskFlow('agent_0', 'agent_7'); // Lead to Synthesis (refinement)
                        visualizeTaskFlow('agent_0', 'agent_2'); // Lead to Tool (additional processing)
                    }
                }, 1300);
            };
            
            initiateValidationPhase();
            
            // Phase 6: Advanced memory and reasoning cycles
            const initiateReasoningPhase = () => {
                setTimeout(() => {
                    if (isResearchActive) {
                        addEmbeddingPoint({ agentType: 'memory_agent' });
                        addEmbeddingPoint({ agentType: 'data_extraction_agent' });
                        // Complex memory integration cycles
                        visualizeTaskFlow('agent_1', 'agent_7'); // Memory to Synthesis
                        visualizeTaskFlow('agent_1', 'agent_0'); // Memory to Lead (status update)
                        visualizeTaskFlow('agent_0', 'agent_1'); // Lead to Memory (new context)
                    }
                }, 1400);
                
                setTimeout(() => {
                    if (isResearchActive) {
                        addEmbeddingPoint({ agentType: 'reasoning_agent' });
                        addEmbeddingPoint({ agentType: 'pattern_agent' });
                        // Bi-directional reasoning
                        visualizeTaskFlow('agent_7', 'agent_1'); // Synthesis to Memory
                        visualizeTaskFlow('agent_7', 'agent_6'); // Synthesis to Citations (cross-reference)
                        visualizeTaskFlow('agent_6', 'agent_7'); // Citations to Synthesis (update)
                    }
                }, 1500);
            };
            
            initiateReasoningPhase();
            
            // Continue adding more nodes with varied timing and types - ENHANCED VERSION
            const addContinuousNodes = () => {
                if (!isResearchActive) return;
                
                // More diverse agent types for richer visualization
                const agentTypes = [
                    'search_agent', 'search_agent', 'search_agent', 'search_agent',
                    'analysis_agent', 'analysis_agent', 'analysis_agent', 'analysis_agent',
                    'synthesis_agent', 'synthesis_agent', 'citation_agent', 'citation_agent',
                    'validation_agent', 'validation_agent', 'context_agent', 'context_agent',
                    'memory_agent', 'memory_agent', 'pattern_agent', 'pattern_agent',
                    'reasoning_agent', 'reasoning_agent', 'data_extraction_agent', 'data_extraction_agent',
                    'factcheck_agent', 'factcheck_agent', 'source_verification_agent', 'source_verification_agent',
                    'concept_mapping_agent', 'concept_mapping_agent', 'trend_analysis_agent', 'trend_analysis_agent'
                ];
                
                // Create multiple agents simultaneously for complex research flows
                const agentBatch = Math.floor(Math.random() * 3) + 1; // 1-3 agents per batch
                for (let i = 0; i < agentBatch; i++) {
                    const randomAgent = agentTypes[Math.floor(Math.random() * agentTypes.length)];
                    console.log(`üé≤ Adding continuous ${randomAgent} point`);
                    addEmbeddingPoint({ agentType: randomAgent });
                }
                
                // Create complex multi-agent research flows - MUCH MORE FREQUENT
                const agentIds = Array.from(agents.keys());
                if (agentIds.length > 1) {
                    // Create 4-8 simultaneous flows for very active research patterns
                    const numFlows = Math.floor(Math.random() * 5) + 4; // 4-8 flows per cycle
                    for (let i = 0; i < numFlows; i++) {
                        const sourceId = agentIds[Math.floor(Math.random() * agentIds.length)];
                        const targetId = agentIds[Math.floor(Math.random() * agentIds.length)];
                        if (sourceId !== targetId) {
                            // Much faster cascade effect
                            setTimeout(() => {
                                visualizeTaskFlow(sourceId, targetId);
                            }, i * 75); // Reduced from 150 to 75
                        }
                    }
                    
                    // More frequent research chains
                    if (Math.random() > 0.4 && agentIds.length > 2) { // Increased from 0.6 to 0.4
                        const chain = [
                            agentIds[Math.floor(Math.random() * agentIds.length)],
                            agentIds[Math.floor(Math.random() * agentIds.length)],
                            agentIds[Math.floor(Math.random() * agentIds.length)]
                        ].filter((id, index, arr) => arr.indexOf(id) === index); // Remove duplicates
                        
                        if (chain.length >= 2) {
                            visualizeTaskFlow(chain[0], chain[1]);
                            if (chain.length === 3) {
                                setTimeout(() => visualizeTaskFlow(chain[1], chain[2]), 300);
                            }
                        }
                    }
                }
                
                // Create specialized research workflows much more frequently
                if (Math.random() > 0.3) { // Increased from 0.7 to 0.3 for much more frequent workflows
                    createSpecializedResearchWorkflow();
                }
                
                // Continue with much faster timing for highly active updates - NO LIMIT UNTIL RESEARCH ENDS
                if (isResearchActive) { // Changed from embedding count limit to research active check
                    const nextInterval = 40 + Math.random() * 40; // Much faster - reduced from 80+80
                    setTimeout(addContinuousNodes, nextInterval);
                }
            };

            // Specialized research workflow patterns
            const createSpecializedResearchWorkflow = () => {
                const agentIds = Array.from(agents.keys());
                if (agentIds.length < 3) return;
                
                const workflows = [
                    // Data validation workflow - MUCH FASTER
                    () => {
                        const search = agentIds.find(id => id.includes('agent_3') || id.includes('agent_4') || id.includes('agent_5')) || agentIds[0];
                        const validation = agentIds.find(id => id.includes('agent_6')) || agentIds[1];
                        const memory = agentIds.find(id => id.includes('agent_1')) || agentIds[2];
                        
                        visualizeTaskFlow(search, validation);
                        setTimeout(() => visualizeTaskFlow(validation, memory), 100); // Reduced from 200
                        setTimeout(() => visualizeTaskFlow(memory, search), 200); // Reduced from 400
                        console.log('üî¨ Data validation workflow triggered');
                    },
                    
                    // Cross-verification workflow - MUCH FASTER
                    () => {
                        const agents = agentIds.slice(0, 4);
                        agents.forEach((agent, i) => {
                            const target = agents[(i + 1) % agents.length];
                            setTimeout(() => visualizeTaskFlow(agent, target), i * 75); // Reduced from 150
                        });
                        console.log('üîÑ Cross-verification workflow triggered');
                    },
                    
                    // Knowledge synthesis workflow
                    () => {
                        const lead = agentIds.find(id => id.includes('agent_0')) || agentIds[0];
                        const synthesis = agentIds.find(id => id.includes('agent_7')) || agentIds[1];
                        const memory = agentIds.find(id => id.includes('agent_1')) || agentIds[2];
                        
                        // Multiple agents send to synthesis - FASTER
                        [1, 2, 3].forEach(i => {
                            setTimeout(() => {
                                const source = agentIds[Math.min(i, agentIds.length - 1)];
                                visualizeTaskFlow(source, synthesis);
                            }, i * 50); // Reduced from 100
                        });
                        
                        // Synthesis sends to memory and lead - FASTER
                        setTimeout(() => {
                            visualizeTaskFlow(synthesis, memory);
                            visualizeTaskFlow(synthesis, lead);
                        }, 250); // Reduced from 500
                        console.log('üß† Knowledge synthesis workflow triggered');
                    }
                ];
                
                const workflow = workflows[Math.floor(Math.random() * workflows.length)];
                workflow();
            };
            
            // Start continuous node generation
            setTimeout(addContinuousNodes, 1600);
        }

        // Create subtle research flow indicators at connection peaks
        function createResearchFlowIndicator(effect) {
            const geometry = effect.line.geometry;
            if (!geometry || !geometry.attributes || !geometry.attributes.position) return;
            
            const positions = geometry.attributes.position.array;
            const indicatorPosition = new THREE.Vector3();
            
            // Calculate position along the line based on progress
            const t = effect.progress;
            indicatorPosition.x = positions[0] + t * (positions[3] - positions[0]);
            indicatorPosition.y = positions[1] + t * (positions[4] - positions[1]);
            indicatorPosition.z = positions[2] + t * (positions[5] - positions[2]);
            
            // Create a small, subtle indicator sphere
            const indicatorGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const indicatorMaterial = new THREE.MeshBasicMaterial({
                color: effect.researchColor,
                transparent: true,
                opacity: 0.6,
                emissive: effect.researchColor,
                emissiveIntensity: 0.3
            });
            
            const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
            indicator.position.copy(indicatorPosition);
            scene.add(indicator);
            
            // Animate and remove the indicator
            let opacity = 0.6;
            let scale = 0.5;
            const animateIndicator = () => {
                opacity -= 0.03;
                scale += 0.02;
                
                indicator.material.opacity = Math.max(0, opacity);
                indicator.scale.setScalar(scale);
                
                if (opacity > 0) {
                    requestAnimationFrame(animateIndicator);
                } else {
                    scene.remove(indicator);
                    indicator.geometry.dispose();
                    indicator.material.dispose();
                }
            };
            animateIndicator();
        }
    </script>
</body>
</html>