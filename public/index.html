<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Agent System Visualizer - Anthropic Architecture</title>
    
    <!-- Three.js CDN with fallback -->
    <script>
        // Check if Three.js loads properly
        window.threeJSLoaded = false;
        window.threeJSLoadError = false;
        
        function loadThreeJS() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
                script.onload = () => {
                    window.threeJSLoaded = true;
                    resolve();
                };
                script.onerror = () => {
                    window.threeJSLoadError = true;
                    reject(new Error('Failed to load Three.js'));
                };
                document.head.appendChild(script);
            });
        }
        
        function loadOrbitControls() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
    </script>
    
    <!-- Socket.io CDN -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
            cursor: crosshair;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #embedding-space {
            position: absolute;
            top: 25px;
            right: 25px;
            width: 400px;
            height: 300px;
            pointer-events: none;
            z-index: 15;
        }

        #embedding-space-label {
            color: #ffffff;
            font-size: 13px;
            font-weight: 500;
            text-align: center;
            margin-bottom: 13px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            opacity: 0.8;
        }

        #embedding-canvas {
            width: 100%;
            height: 270px;
            background: transparent;
        }

        #header {
            position: absolute;
            top: 25px;
            left: 25px;
            background: rgba(0, 0, 0, 0.6);
            padding: 24px 28px;
            border-radius: 16px;
            pointer-events: auto;
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            width: 330px;
        }

        #header h1 {
            color: #ffffff;
            font-size: 24px;
            margin-bottom: 9px;
            font-weight: 400;
            letter-spacing: 0.5px;
            line-height: 1.2;
        }

        #header p {
            color: #666;
            font-size: 12px;
            margin-bottom: 4px;
        }
        
        .tech-links {
            display: inline-flex;
            gap: 8px;
        }
        
        .tech-link {
            color: #00ff88;
            text-decoration: none;
            text-shadow: 0 0 8px rgba(0, 255, 136, 0.6);
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .tech-link:hover {
            color: #ffffff;
            text-shadow: 0 0 12px rgba(0, 255, 136, 0.9);
            transform: translateY(-1px);
        }

        #header .tech-stack {
            color: #b0b0b0;
            font-size: 11px;
            font-weight: 300;
            margin-top: 8px;
            margin-bottom: 10px;
            letter-spacing: 0.3px;
        }
        
        #header .architecture-info {
            color: #00cc66;
            font-size: 12px;
            margin-bottom: 9px;
            line-height: 1.3;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            text-shadow: 0 0 6px rgba(0, 204, 102, 0.4);
        }
         
        #header .architecture-info a {
            color: #8866ff;
            text-decoration: none;
            transition: all 0.3s ease;
        }
        
        #header .architecture-info a:hover {
            color: #ffffff;
            text-shadow: 0 0 10px rgba(0, 204, 102, 0.7);
        }

        .header-links {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-start;
            margin-top: 12px;
        }

        #research-panel {
            position: absolute;
            bottom: 25px;
            left: 25px;
            background: rgba(0, 0, 0, 0.4);
            padding: 17px;
            border-radius: 12px;
            pointer-events: auto;
            backdrop-filter: blur(15px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            width: 308px;
        }

        #research-panel h3 {
            color: #ffffff;
            font-size: 11px;
            margin-bottom: 11px;
            font-weight: 400;
            letter-spacing: 0.5px;
            opacity: 0.6;
        }

        .research-input-container {
            display: flex;
            gap: 9px;
            margin-bottom: 11px;
        }

        .research-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            padding: 9px 13px;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            outline: none;
            transition: all 0.3s ease;
        }

        .research-input:focus {
            border-color: #ffffff;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        .research-button {
            background: #ffffff;
            border: none;
            border-radius: 6px;
            padding: 9px 13px;
            color: #000;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            min-width: 44px;
            font-weight: 500;
        }

        .research-button:hover {
            background: #f0f0f0;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.3);
        }

        .research-button:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
        }

        .research-status {
            font-size: 12px;
            line-height: 1.4;
        }
        
        .research-controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 11px;
            gap: 8px;
        }
        
        .clear-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 7px 13px;
            color: #fff;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
            font-family: 'Courier New', monospace;
        }
        
        .clear-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
        }

        #loading h2 {
            color: #00ff88;
            font-size: 24px;
            margin-bottom: 20px;
            font-weight: 400;
            letter-spacing: 1px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #00ff88;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 0, 0, 0.1);
            padding: 30px;
            border-radius: 16px;
            border: 1px solid rgba(255, 0, 0, 0.3);
            display: none;
            z-index: 100;
        }

        #error-message h3 {
            color: #ff6b6b;
            margin-bottom: 15px;
        }

        #error-message p {
            color: #ccc;
            font-size: 14px;
        }

        #tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 320px;
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.6);
            display: none;
        }

        .fadeInUp {
            animation: fadeInUp 0.3s ease;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #error-message h3 {
            color: #ff6b6b;
            font-size: 18px;
            margin-bottom: 10px;
        }

        #error-message p {
            color: #ffffff;
            font-size: 14px;
            line-height: 1.5;
        }

    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="ui">
            <div id="header">
                <h1>Multi-Agent  System Visualizer</h1>
                <p>Powered by 
                    <span class="tech-links">
                        <a href="https://docs.astro.build/en/getting-started/" target="_blank" class="tech-link">Astro</a>
                        <span style="color: #666;"> + </span>
                        <a href="https://www.langchain.com/langgraph" target="_blank" class="tech-link">LangGraph</a>
                    </span>
                </p>
                <div class="header-links">
                    <div class="architecture-info">
                        <a href="#" onclick="showArchitectureInfo()">ANTHROPIC ARCHITECTURE</a>
                    </div>
                    <div class="architecture-info">
                        <a href="https://github.com/abdulmalikds" target="_blank">@ABDULMALIKDS</a>
                    </div>
                </div>
            </div>

            <div id="embedding-space">
                <div id="embedding-space-label">Embedding Space</div>
                <canvas id="embedding-canvas"></canvas>
            </div>

            <div id="research-panel">
                <h3>Research</h3>
                <div class="research-input-container">
                    <input type="text" id="researchTopic" placeholder="Enter research topic..." class="research-input">
                    <button onclick="startUserResearch()" class="research-button">Search</button>
                </div>
                
                <div class="research-controls">
                    <button onclick="clearResearchVisualizations()" class="clear-button">Clear</button>
                    <button onclick="exportResearchResults()" class="clear-button">Export</button>
                </div>
                <div class="research-status" id="researchStatus"></div>
            </div>
        </div>
        
        <div id="loading">
            <h2>Initializing Research Network...</h2>
            <div class="spinner"></div>
        </div>
        
        <div id="error-message" style="display: none;">
            <h2>Critical Error</h2>
            <p>Could not load essential components. Please refresh the page.</p>
        </div>
        
        <div id="tooltip"></div>
    </div>
    
    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let agents = new Map();
        let connections = [];
        let particles = []; // For visualizing interactions
        let embeddings = []; // Embeddings in main scene - starts empty, no initial embeddings
        let socket;

        // Embedding space visualization
        let embeddingScene, embeddingCamera, embeddingRenderer;
        let embeddingPoints = [];
        let embeddingConnections = [];
        let embeddingAnimationId;
        let isResearchActive = false;
        let researchStartTime = 0;
        let totalInteractions = 0;
        let researchTopic = '';
        let researchResults = {
            topic: '',
            startTime: 0,
            endTime: 0,
            totalNodes: 0,
            totalConnections: 0,
            agentInteractions: [],
            embeddingPoints: [],
            connections: [],
            perplexityResults: [], // Store actual Perplexity search results
            agentAnalysis: [], // Store agent analysis results
            citations: [], // Store citations and sources
            finalSummary: '' // Store final research summary
        };
        
        // Agent specializations matching server
        const agentSpecializations = {
            'technical_analyst': { color: '#00ff88', name: 'ðŸ”§ Technical Analyst', expertise: ['technical', 'implementation', 'systems'] },
            'trend_researcher': { color: '#ff8800', name: 'ðŸ“ˆ Trend Researcher', expertise: ['trends', 'market', 'adoption'] },
            'impact_assessor': { color: '#ff0088', name: 'ðŸŽ¯ Impact Assessor', expertise: ['impact', 'implications', 'consequences'] },
            'context_synthesizer': { color: '#8800ff', name: 'ðŸ§  Context Synthesizer', expertise: ['synthesis', 'connections', 'relationships'] },
            'evidence_validator': { color: '#0088ff', name: 'âœ… Evidence Validator', expertise: ['validation', 'verification', 'accuracy'] }
        };

        // Smart Hover State Management System
        let hoverState = {
            currentAgent: null,
            tooltipVisible: false,
            hoverTimeout: null,
            lastHoverTime: 0
        };

        // Timeout ID for delayed tooltip hiding
        let tooltipHideTimeout = null;
        
        function hideTooltipWithDelay() {
            if (tooltipHideTimeout) {
                clearTimeout(tooltipHideTimeout);
            }
            tooltipHideTimeout = setTimeout(() => {
                hideTooltip();
                hoverState.tooltipVisible = false;
                hoverState.currentAgent = null;
            }, 150);
        }

        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }

        // Minimal debug logging to reduce console popups
        function debugLog(message, type = 'info') {
            // Only log critical errors to reduce popup messages
            if (type === 'error') {
                console.error(`[ERROR] ${message}`);
            }
            // Silently ignore other log types to reduce console noise
        }

        // Check if Three.js is loaded
        function checkThreeJS() {
            if (typeof THREE === 'undefined') {
                debugLog('Three.js not loaded, showing error message', 'error');
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error-message').style.display = 'block';
                return false;
            }
            
            if (typeof THREE.OrbitControls === 'undefined') {
                debugLog('OrbitControls not loaded, but Three.js is available', 'warning');
            }
            
            return true;
        }

        // Initialize the application
        async function init() {
            try {
                // Load Three.js if not already loaded
                if (typeof THREE === 'undefined') {
                    await loadThreeJS();
                }
                
                if (typeof THREE.OrbitControls === 'undefined') {
                    await loadOrbitControls();
                }
                
                // Hide loading screen
                const loadingScreen = document.getElementById('loading');
                if (loadingScreen) {
                    loadingScreen.style.display = 'none';
                }
                
                if (!checkThreeJS()) {
                    return;
                }
                
                // Initialize Three.js components
                initThreeJS();
                
                // Initialize embedding space
                initEmbeddingSpace();
                
                // Initialize WebSocket connection
                initWebSocket();
                
                // Start animation loop
                animate();
                
                // Add event listeners
                addEventListeners();
                
                debugLog('Application initialized successfully', 'info');
                
            } catch (error) {
                debugLog(`Initialization error: ${error.message}`, 'error');
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error-message').style.display = 'block';
            }
        }

        // Scene setup with darker background like reference
        function initThreeJS() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // Match reference background
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 18); // Adjusted for a better view
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Controls setup
            if (typeof THREE.OrbitControls !== 'undefined') {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
            }
            
            // Enhanced lighting for architectural visualization
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            // Primary directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);
            
            // Secondary light for better depth
            const secondaryLight = new THREE.DirectionalLight(0x4488ff, 0.3);
            secondaryLight.position.set(-8, -5, 8);
            scene.add(secondaryLight);
            
            // Accent light for highlighting
            const accentLight = new THREE.PointLight(0x88ff88, 0.4, 20);
            accentLight.position.set(0, 5, 0);
            scene.add(accentLight);
            
            // Create initial agents
            console.log('ðŸ—ï¸ Creating initial agents...');
            createInitialAgents();
            console.log('âœ… Initial agents created');
        }

        // Create initial agents in an Anthropic-inspired architectural formation
        function createInitialAgents() {
            const agentData = [
                // Central Lead Agent (Orchestrator) - Diamond shape, larger
                { 
                    name: 'Lead Orchestrator', 
                    role: 'Research Orchestrator', 
                    color: 0x00ff88, 
                    position: [0, 2, 0], 
                    size: 1.0,
                    shape: 'diamond',
                    description: 'Main orchestrator coordinating all research activities',
                    specialization: 'orchestration'
                },
                
                // Memory Database - Stack of cubes to represent database layers
                { 
                    name: 'Memory Database', 
                    role: 'Persistent Storage', 
                    color: 0x6644aa, 
                    position: [4, 1.5, -1], 
                    size: 0.6,
                    shape: 'database',
                    description: 'Vector database for context and memory storage',
                    specialization: 'database'
                },
                
                // Tools Database - Hammer shape for tool repository
                { 
                    name: 'Tools Database', 
                    role: 'API Repository', 
                    color: 0xaa6644, 
                    position: [-4, 1.5, -1], 
                    size: 0.6,
                    shape: 'hammer',
                    description: 'Tool registry and API management system',
                    specialization: 'tools'
                },
                
                // Search Subagents - Spheres in formation
                { 
                    name: 'Search Agent Alpha', 
                    role: 'Primary Search', 
                    color: 0x0088ff, 
                    position: [-2.5, -1.5, 2], 
                    size: 0.6,
                    shape: 'sphere',
                    description: 'Specialized web search and information retrieval',
                    specialization: 'search'
                },
                { 
                    name: 'Search Agent Beta', 
                    role: 'Parallel Search', 
                    color: 0x0088ff, 
                    position: [0, -2, 3], 
                    size: 0.6,
                    shape: 'sphere',
                    description: 'Parallel search processing for comprehensive coverage',
                    specialization: 'search'
                },
                { 
                    name: 'Search Agent Gamma', 
                    role: 'Multi-Source Search', 
                    color: 0x0088ff, 
                    position: [2.5, -1.5, 2], 
                    size: 0.6,
                    shape: 'sphere',
                    description: 'Aggregates results from multiple search sources',
                    specialization: 'search'
                },
                
                // Citations and Analysis Agent - Octahedron for analysis
                { 
                    name: 'Citations Agent', 
                    role: 'Source Verification', 
                    color: 0xff0088, 
                    position: [3, 0, -3], 
                    size: 0.7,
                    shape: 'octahedron',
                    description: 'Validates sources and manages citations',
                    specialization: 'citations'
                },
                
                // Analysis and Synthesis Agent - Tetrahedron for synthesis
                { 
                    name: 'Synthesis Agent', 
                    role: 'Knowledge Synthesis', 
                    color: 0x88ff00, 
                    position: [-3, 0, -3], 
                    size: 0.7,
                    shape: 'tetrahedron',
                    description: 'Analyzes and synthesizes information into insights',
                    specialization: 'synthesis'
                }
            ];
            
            console.log(`ðŸ¤– Creating ${agentData.length} specialized agents...`);
            agentData.forEach((data, index) => {
                console.log(`Creating ${data.specialization} agent: ${data.name}`);
                createAgent(data, index);
            });
            
            // Create architectural connections
            console.log('ðŸ”— Creating architectural agent connections...');
            createAgentConnections();
            console.log('âœ… Multi-agent architecture initialized');
        }

        // Create a single agent with specialized geometry and labels
        function createAgent(data, index) {
            let geometry;
            let shouldHaveGlow = false;
            
            // Create different geometries based on agent specialization
            switch(data.shape || 'sphere') {
                case 'diamond':
                    geometry = new THREE.OctahedronGeometry(data.size * 0.8, 0);
                    shouldHaveGlow = true; // Lead orchestrator should glow
                    break;
                case 'hammer':
                    // Create hammer shape using grouped geometries
                    const hammerGroup = new THREE.Group();
                    
                    // Hammer handle (long cylinder)
                    const handleGeometry = new THREE.CylinderGeometry(data.size * 0.15, data.size * 0.15, data.size * 2, 8);
                    const handleMaterial = new THREE.MeshLambertMaterial({ 
                        color: new THREE.Color(data.color).multiplyScalar(0.7),
                        transparent: true,
                        opacity: 0.8
                    });
                    const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                    handle.position.y = -data.size * 0.3;
                    hammerGroup.add(handle);
                    
                    // Hammer head (box)
                    const headGeometry = new THREE.BoxGeometry(data.size * 1.2, data.size * 0.5, data.size * 0.4);
                    const headMaterial = new THREE.MeshLambertMaterial({ 
                        color: data.color,
                        transparent: true,
                        opacity: 0.85
                    });
                    const head = new THREE.Mesh(headGeometry, headMaterial);
                    head.position.y = data.size * 0.7;
                    hammerGroup.add(head);
                    
                    geometry = hammerGroup;
                    break;
                case 'database':
                    // Create database-like stacked cylinders
                    const dbGroup = new THREE.Group();
                    for (let i = 0; i < 3; i++) {
                        const diskGeometry = new THREE.CylinderGeometry(data.size * 0.8, data.size * 0.8, data.size * 0.2, 16);
                        const diskMaterial = new THREE.MeshLambertMaterial({ 
                            color: data.color,
                            transparent: true,
                            opacity: 0.8
                        });
                        const disk = new THREE.Mesh(diskGeometry, diskMaterial);
                        disk.position.y = i * data.size * 0.3 - data.size * 0.3;
                        dbGroup.add(disk);
                    }
                    geometry = dbGroup;
                    break;
                case 'cube':
                    geometry = new THREE.BoxGeometry(data.size * 1.2, data.size * 1.2, data.size * 1.2);
                    break;
                case 'hexagon':
                    geometry = new THREE.CylinderGeometry(data.size * 0.8, data.size * 0.8, data.size * 0.4, 6);
                    break;
                case 'octahedron':
                    geometry = new THREE.OctahedronGeometry(data.size * 0.7, 0);
                    shouldHaveGlow = true; // Citations agent should glow
                    break;
                case 'tetrahedron':
                    geometry = new THREE.TetrahedronGeometry(data.size * 0.8, 0);
                    shouldHaveGlow = true; // Synthesis agent should glow
                    break;
                default: // sphere - search agents
                    geometry = new THREE.SphereGeometry(data.size, 16, 16);
                    shouldHaveGlow = true; // Search agents should glow
            }
            
            let mesh;
            if (data.shape === 'database' || data.shape === 'hammer') {
                // For database and hammer, geometry is already a group
                mesh = geometry;
                mesh.position.set(...data.position);
            } else {
                const material = new THREE.MeshLambertMaterial({ 
                    color: data.color,
                    transparent: true,
                    opacity: 0.85,
                    emissive: shouldHaveGlow ? data.color : 0x000000,
                    emissiveIntensity: shouldHaveGlow ? 0.1 : 0
                });
                
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(...data.position);
            }
            
            // Add glow effect only for agents (not databases)
            let glowMesh = null;
            if (shouldHaveGlow && data.shape !== 'database') {
                const glowGeometry = geometry.clone();
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: data.color,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.BackSide
                });
                glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                glowMesh.scale.multiplyScalar(1.3);
                glowMesh.position.copy(mesh.position);
            }
            
            // Create text label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            // Style the text
            context.font = 'bold 18px Arial';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.fillText(data.name, 128, 32);
            
            // Create texture from canvas
            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                alphaTest: 0.1
            });
            const labelSprite = new THREE.Sprite(labelMaterial);
            labelSprite.scale.set(2.5, 0.6, 1);
            labelSprite.position.set(data.position[0], data.position[1] + data.size + 1, data.position[2]);
            
            // Store agent data
            mesh.userData = {
                name: data.name,
                role: data.role,
                color: data.color,
                agentId: `agent_${index}`,
                state: 'idle',
                currentTask: 'Standby',
                taskProgress: 0,
                lastInteraction: Date.now(),
                originalScale: data.size,
                specialization: data.specialization,
                description: data.description,
                shape: data.shape || 'sphere',
                label: labelSprite,
                glow: glowMesh,
                isDatabase: data.specialization === 'database'
            };
            
            // Add to scene
            scene.add(mesh);
            if (glowMesh) {
                scene.add(glowMesh);
            }
            scene.add(labelSprite);
            
            agents.set(`agent_${index}`, { mesh, data });
            
            console.log(`âœ… Created ${data.specialization} ${data.specialization === 'database' ? 'database' : 'agent'}: ${data.name} (${data.shape || 'sphere'})`);
        }

        // Create connections in an architectural multi-agent system pattern
        function createAgentConnections() {
            const agentKeys = Array.from(agents.keys());
            
            // Primary architectural connections (Lead Orchestrator at center)
            const leadOrchestrator = agents.get('agent_0'); // Lead Orchestrator
            const memorySystem = agents.get('agent_1');     // Memory System
            const toolAgent = agents.get('agent_2');        // Tool Agent
            const searchAlpha = agents.get('agent_3');      // Search Agent Alpha
            const searchBeta = agents.get('agent_4');       // Search Agent Beta  
            const searchGamma = agents.get('agent_5');      // Search Agent Gamma
            const citationsAgent = agents.get('agent_6');   // Citations Agent
            const synthesisAgent = agents.get('agent_7');   // Synthesis Agent
            
            // Core architectural connections - Lead Orchestrator to key systems
            const primaryConnections = [
                { from: leadOrchestrator, to: memorySystem, color: 0x8800ff, opacity: 0.6, width: 3 },
                { from: leadOrchestrator, to: toolAgent, color: 0xff8800, opacity: 0.6, width: 3 },
                { from: leadOrchestrator, to: citationsAgent, color: 0xff0088, opacity: 0.5, width: 2 },
                { from: leadOrchestrator, to: synthesisAgent, color: 0x88ff00, opacity: 0.5, width: 2 }
            ];
            
            // Search agent cluster connections
            const searchConnections = [
                { from: leadOrchestrator, to: searchAlpha, color: 0x0088ff, opacity: 0.4, width: 2 },
                { from: leadOrchestrator, to: searchBeta, color: 0x0088ff, opacity: 0.4, width: 2 },
                { from: leadOrchestrator, to: searchGamma, color: 0x0088ff, opacity: 0.4, width: 2 },
                { from: searchAlpha, to: searchBeta, color: 0x0088ff, opacity: 0.3, width: 1 },
                { from: searchBeta, to: searchGamma, color: 0x0088ff, opacity: 0.3, width: 1 },
                { from: searchGamma, to: searchAlpha, color: 0x0088ff, opacity: 0.3, width: 1 }
            ];
            
            // Data flow connections (functional relationships)
            const dataFlowConnections = [
                { from: searchAlpha, to: citationsAgent, color: 0x4488ff, opacity: 0.3, width: 1 },
                { from: searchBeta, to: citationsAgent, color: 0x4488ff, opacity: 0.3, width: 1 },
                { from: searchGamma, to: citationsAgent, color: 0x4488ff, opacity: 0.3, width: 1 },
                { from: citationsAgent, to: synthesisAgent, color: 0xff4488, opacity: 0.4, width: 2 },
                { from: synthesisAgent, to: memorySystem, color: 0x88ff88, opacity: 0.4, width: 2 },
                { from: toolAgent, to: searchAlpha, color: 0xff8844, opacity: 0.3, width: 1 },
                { from: memorySystem, to: synthesisAgent, color: 0xaa88ff, opacity: 0.3, width: 1 }
            ];
            
            // Create all connections
            function createConnection(connectionData) {
                if (connectionData.from && connectionData.to) {
                    const points = [
                        connectionData.from.mesh.position.clone(),
                        connectionData.to.mesh.position.clone()
                    ];
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({
                        color: connectionData.color,
                        transparent: true,
                        opacity: connectionData.opacity,
                        linewidth: connectionData.width || 2
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    line.userData = {
                        type: 'agent_connection',
                        agent1: connectionData.from.mesh,
                        agent2: connectionData.to.mesh,
                        strength: connectionData.opacity,
                        connectionType: connectionData.type || 'architectural'
                    };
                    
                    scene.add(line);
                    connections.push(line);
                }
            }
            
            // Apply all connection sets
            console.log('ðŸ”— Creating primary architectural connections...');
            primaryConnections.forEach(createConnection);
            
            console.log('ðŸ” Creating search agent cluster connections...');
            searchConnections.forEach(createConnection);
            
            console.log('ðŸ“Š Creating data flow connections...');
            dataFlowConnections.forEach(createConnection);
            
            console.log(`âœ… Created ${connections.length} architectural connections`);
        }

        // Initialize WebSocket connection with enhanced handlers
        function initWebSocket() {
            try {
                console.log('ðŸ”Œ Initializing WebSocket connection...');
                socket = io();
                
                socket.on('connect', () => {
                    console.log('âœ… Connected to Anthropic-style multi-agent research system');
                });
                
                socket.on('disconnect', () => {
                    console.log('Disconnected from server');
                });
                
                socket.on('researchUpdate', (data) => {
                    console.log('ðŸ“¡ Research update:', data);
                    handleAnthropicResearchUpdate(data);
                    
                    // Capture actual research data for export
                    if (data.type === 'perplexity_result') {
                        researchResults.perplexityResults.push({
                            timestamp: Date.now() - researchResults.startTime,
                            query: data.query,
                            results: data.results,
                            sources: data.sources || []
                        });
                    } else if (data.type === 'agent_analysis') {
                        researchResults.agentAnalysis.push({
                            timestamp: Date.now() - researchResults.startTime,
                            agent: data.agent,
                            analysis: data.analysis,
                            insights: data.insights || []
                        });
                    } else if (data.type === 'citations') {
                        researchResults.citations.push({
                            timestamp: Date.now() - researchResults.startTime,
                            sources: data.sources,
                            citations: data.citations
                        });
                    } else if (data.type === 'final_summary') {
                        researchResults.finalSummary = data.summary;
                    }
                });
                
                socket.on('newEmbedding', (embedding) => {
                    console.log('âœ¨ New embedding:', embedding);
                    if (embedding && embedding.x !== undefined) {
                        addEmbeddingToMainScene(embedding);
                        
                        // Store actual embedding data for export
                        researchResults.embeddingPoints.push({
                            id: embedding.id,
                            text: embedding.text || '',
                            metadata: embedding.metadata || {},
                            position: {
                                x: embedding.x,
                                y: embedding.y,
                                z: embedding.z
                            },
                            timestamp: Date.now() - researchResults.startTime,
                            source: embedding.source || 'unknown'
                        });
                    }
                });
                
                socket.on('researchComplete', (data) => {
                    handleResearchComplete(data);
                    
                    // Store final research completion data
                    researchResults.endTime = Date.now();
                    if (data.summary) {
                        researchResults.finalSummary = data.summary;
                    }
                    if (data.totalResults) {
                        researchResults.totalResults = data.totalResults;
                    }
                    if (data.keyFindings) {
                        researchResults.keyFindings = data.keyFindings;
                    }
                });
                
                socket.on('enhancedAgentData', (data) => {
                    handleEnhancedAgentData(data);
                });
                
            } catch (error) {
                console.error(`WebSocket connection error: ${error.message}`);
            }
        }

        // Add embedding to the main 3D scene with agents - static, no animation
        function addEmbeddingToMainScene(embeddingData) {
            if (!scene) return;

            const position = {
                x: embeddingData.x * 2, // Scale for better visibility
                y: embeddingData.y * 2,
                z: embeddingData.z * 2
            };
            if (position.x === undefined) return;

            // Determine color based on the type of embedding
            const typeColors = {
                'perplexity_search': 0x00aaff, // Blue for Perplexity
                'agent_analysis': 0xffaa00, // Orange for Sub-agent work
                'initial_search': 0xffff00, // Yellow for initial search
                'default': 0xffffff // White for others
            };
            const color = typeColors[embeddingData.metadata?.type] || typeColors['default'];

            // Create a minimal embedding point
            const geometry = new THREE.SphereGeometry(0.2, 12, 12);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8
            });
            const mesh = new THREE.Mesh(geometry, material);
            
            // Set to final position immediately - no animation
            mesh.position.set(position.x, position.y, position.z);
            
            mesh.userData = {
                id: embeddingData.id,
                type: embeddingData.metadata?.type || 'default',
                timestamp: Date.now(),
                staticPosition: position // Store static position
            };

            scene.add(mesh);
            embeddings.push(mesh);
            
            // Create connections to nearest embeddings (k-nearest neighbors)
            createEmbeddingConnections(mesh);
            
            console.log(`âœ¨ Added static embedding to main scene: ${embeddingData.id} at position (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)})`);
        }

        // Create connections between embeddings (k-nearest neighbors approach)
        function createEmbeddingConnections(newEmbedding) {
            const maxConnections = 3; // Connect to 3 nearest embeddings
            const maxDistance = 8.0; // Maximum distance for connections
            
            // Find distances to all other embeddings
            const distances = [];
            embeddings.forEach(embedding => {
                if (embedding !== newEmbedding) {
                    const distance = newEmbedding.position.distanceTo(embedding.position);
                    if (distance <= maxDistance) {
                        distances.push({ embedding, distance });
                    }
                }
            });
            
            // Sort by distance and take the closest ones
            distances.sort((a, b) => a.distance - b.distance);
            const nearestEmbeddings = distances.slice(0, maxConnections);
            
            // Create connections to nearest embeddings
            nearestEmbeddings.forEach(({ embedding, distance }) => {
                const points = [
                    newEmbedding.position.clone(),
                    embedding.position.clone()
                ];
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0x44ff88,
                    transparent: true,
                    opacity: 0.4 * (1 - distance / maxDistance), // Fade with distance
                    linewidth: 1
                });
                
                const line = new THREE.Line(geometry, material);
                line.userData = {
                    type: 'embedding_connection',
                    embedding1: newEmbedding,
                    embedding2: embedding,
                    distance: distance
                };
                
                scene.add(line);
                connections.push(line);
            });
        }


        
        // Main animation loop - agents now remain completely static
        function animate() {
            requestAnimationFrame(animate);

            // Update controls
            if (controls) {
                controls.update();
            }

            // Only animate interaction particles (task flow particles)
            particles.forEach((particle, index) => {
                particle.progress += particle.speed;
                if (particle.progress >= 1) {
                    scene.remove(particle.mesh);
                    particles.splice(index, 1);
                } else {
                    // Move particle along the curve
                    const point = particle.curve.getPoint(particle.progress);
                    particle.mesh.position.copy(point);
                }
            });

            // Render main scene
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }



        // Agent Interaction System
        function startLogicalAgentWorkflow() {
            console.log('ðŸ”„ Starting logical multi-agent research workflow');
            
            const leadAgent = Array.from(agents.values()).find(a => a.data.specialization === 'orchestration');
            const searchAgents = Array.from(agents.values()).filter(a => a.data.specialization === 'search');
            const memoryAgent = Array.from(agents.values()).find(a => a.data.name.includes('Memory'));
            const toolsAgent = Array.from(agents.values()).find(a => a.data.name.includes('Tools'));
            const citationAgent = Array.from(agents.values()).find(a => a.data.specialization === 'citations');
            const synthesisAgent = Array.from(agents.values()).find(a => a.data.specialization === 'synthesis');
            
            if (!leadAgent || searchAgents.length === 0) {
                console.warn('Required agents not found for workflow');
                return;
            }
            
            // Phase 1: Lead Orchestrator accesses tools and memory (immediate)
            setTimeout(() => {
                if (toolsAgent) {
                    visualizeTaskFlow(leadAgent.mesh.userData.agentId, toolsAgent.mesh.userData.agentId);
                    console.log('ðŸ“Š Lead â†’ Tools: Accessing research tools');
                }
                if (memoryAgent) {
                    setTimeout(() => {
                        visualizeTaskFlow(leadAgent.mesh.userData.agentId, memoryAgent.mesh.userData.agentId);
                        console.log('ðŸ§  Lead â†’ Memory: Checking context');
                    }, 300);
                }
            }, 500);
            
            // Phase 2: Deploy search agents (1.5-3 seconds)
            setTimeout(() => {
                searchAgents.forEach((agent, i) => {
                    setTimeout(() => {
                        visualizeTaskFlow(leadAgent.mesh.userData.agentId, agent.mesh.userData.agentId);
                        console.log(`ðŸ” Lead â†’ Search Agent ${i + 1}: Deploy search task`);
                    }, i * 400);
                });
            }, 1500);
            
            // Phase 3: Search agents return results (4-7 seconds)
            setTimeout(() => {
                searchAgents.forEach((agent, i) => {
                    setTimeout(() => {
                        visualizeTaskFlow(agent.mesh.userData.agentId, leadAgent.mesh.userData.agentId);
                        console.log(`ðŸ“¥ Search Agent ${i + 1} â†’ Lead: Returning results`);
                    }, i * 600);
                });
            }, 4000);
            
            // Phase 4: Sub agents send tool requirements to Tools Database (6-7.5 seconds)
            setTimeout(() => {
                if (toolsAgent) {
                    // Search agents request additional tools
                    searchAgents.forEach((agent, i) => {
                        setTimeout(() => {
                            visualizeTaskFlow(agent.mesh.userData.agentId, toolsAgent.mesh.userData.agentId);
                            console.log(`ðŸ”¨ Search Agent ${i + 1} â†’ Tools: Requesting analysis tools`);
                        }, i * 300);
                    });
                    
                    // Citations agent requests verification tools
                    if (citationAgent) {
                        setTimeout(() => {
                            visualizeTaskFlow(citationAgent.mesh.userData.agentId, toolsAgent.mesh.userData.agentId);
                            console.log('ðŸ”¨ Citations â†’ Tools: Requesting verification tools');
                        }, 800);
                    }
                    
                    // Synthesis agent requests processing tools
                    if (synthesisAgent) {
                        setTimeout(() => {
                            visualizeTaskFlow(synthesisAgent.mesh.userData.agentId, toolsAgent.mesh.userData.agentId);
                            console.log('ðŸ”¨ Synthesis â†’ Tools: Requesting processing tools');
                        }, 1200);
                    }
                }
            }, 6000);
            
            // Phase 5: Lead sends data to citations for verification (8 seconds)
            setTimeout(() => {
                if (citationAgent) {
                    visualizeTaskFlow(leadAgent.mesh.userData.agentId, citationAgent.mesh.userData.agentId);
                    console.log('âœ… Lead â†’ Citations: Verify sources');
                    
                    // Search agents also feed directly into citations
                    searchAgents.forEach((agent, i) => {
                        setTimeout(() => {
                            visualizeTaskFlow(agent.mesh.userData.agentId, citationAgent.mesh.userData.agentId);
                            console.log(`ðŸ“„ Search Agent ${i + 1} â†’ Citations: Raw source data`);
                        }, 500 + i * 300);
                    });
                }
            }, 8000);
            
            // Phase 6: Citations to synthesis (11 seconds)
            setTimeout(() => {
                if (citationAgent && synthesisAgent) {
                    visualizeTaskFlow(citationAgent.mesh.userData.agentId, synthesisAgent.mesh.userData.agentId);
                    console.log('ðŸ”¬ Citations â†’ Synthesis: Verified data for analysis');
                }
            }, 11000);
            
            // Phase 7: Memory retrieval for synthesis (12 seconds)
            setTimeout(() => {
                if (memoryAgent && synthesisAgent) {
                    visualizeTaskFlow(memoryAgent.mesh.userData.agentId, synthesisAgent.mesh.userData.agentId);
                    console.log('ðŸ§  Memory â†’ Synthesis: Historical context');
                }
            }, 12000);
            
            // Phase 8: Synthesis back to lead and memory storage (15 seconds)
            setTimeout(() => {
                if (synthesisAgent) {
                    // Synthesis to Lead
                    visualizeTaskFlow(synthesisAgent.mesh.userData.agentId, leadAgent.mesh.userData.agentId);
                    console.log('ðŸŽ¯ Synthesis â†’ Lead: Final analysis');
                    
                    // Synthesis to Memory (store results)
                    if (memoryAgent) {
                        setTimeout(() => {
                            visualizeTaskFlow(synthesisAgent.mesh.userData.agentId, memoryAgent.mesh.userData.agentId);
                            console.log('ðŸ’¾ Synthesis â†’ Memory: Store insights');
                        }, 800);
                    }
                }
            }, 15000);
            
            // Phase 9: Continuous memory sync (18-25 seconds)
            setTimeout(() => {
                if (memoryAgent) {
                    [citationAgent, synthesisAgent].forEach((agent, i) => {
                        if (agent) {
                            setTimeout(() => {
                                visualizeTaskFlow(agent.mesh.userData.agentId, memoryAgent.mesh.userData.agentId);
                                console.log(`ðŸ’¾ ${agent.data.name} â†’ Memory: Continuous sync`);
                            }, i * 1500);
                        }
                    });
                }
            }, 18000);
            
            console.log('âœ… Logical workflow sequence initiated');
        }
        
        window.triggerInteraction = function(type) {
            console.log(`ðŸŽ­ Triggering ${type} interaction`);
            
            const leadAgent = Array.from(agents.values()).find(a => a.data.specialization === 'orchestration');
            const searchAgents = Array.from(agents.values()).filter(a => a.data.specialization === 'search');
            const memoryAgent = Array.from(agents.values()).find(a => a.data.name.includes('Memory'));
            
            switch(type) {
                case 'workflow':
                    if (leadAgent && searchAgents.length > 0) {
                        searchAgents.forEach((agent, i) => {
                            setTimeout(() => {
                                visualizeTaskFlow(leadAgent.mesh.userData.agentId, agent.mesh.userData.agentId);
                            }, i * 500);
                        });
                    }
                    break;
                    
                case 'memory_sync':
                    if (memoryAgent) {
                        agents.forEach((agent) => {
                            if (agent.data.specialization !== 'database') {
                                setTimeout(() => {
                                    visualizeTaskFlow(agent.mesh.userData.agentId, memoryAgent.mesh.userData.agentId);
                                }, Math.random() * 2000);
                            }
                        });
                    }
                    break;
                    
                case 'burst_search':
                    if (leadAgent) {
                        searchAgents.forEach((agent, i) => {
                            setTimeout(() => {
                                visualizeTaskFlow(leadAgent.mesh.userData.agentId, agent.mesh.userData.agentId);
                                setTimeout(() => {
                                    visualizeTaskFlow(agent.mesh.userData.agentId, leadAgent.mesh.userData.agentId);
                                }, 1000);
                            }, i * 200);
                        });
                    }
                    break;
                    
                case 'analysis_chain':
                    const citationAgent = Array.from(agents.values()).find(a => a.data.specialization === 'citations');
                    const synthesisAgent = Array.from(agents.values()).find(a => a.data.specialization === 'synthesis');
                    
                    if (searchAgents.length > 0 && citationAgent && synthesisAgent) {
                        visualizeTaskFlow(searchAgents[0].mesh.userData.agentId, citationAgent.mesh.userData.agentId);
                        setTimeout(() => {
                            visualizeTaskFlow(citationAgent.mesh.userData.agentId, synthesisAgent.mesh.userData.agentId);
                        }, 1500);
                        setTimeout(() => {
                            if (memoryAgent) {
                                visualizeTaskFlow(synthesisAgent.mesh.userData.agentId, memoryAgent.mesh.userData.agentId);
                            }
                        }, 3000);
                    }
                    break;
            }
        };


        // Add event listeners for interaction
        function addEventListeners() {
            // Window resize handler
            window.addEventListener('resize', onWindowResize, false);
            
            // Add mouse interaction for agents (optional)
            if (renderer && renderer.domElement) {
                renderer.domElement.addEventListener('mousemove', onMouseMove, false);
                renderer.domElement.addEventListener('mouseleave', onMouseLeave, false);
            }
            
            // Add Enter key support for research input
            const researchInput = document.getElementById('researchTopic');
            if (researchInput) {
                researchInput.addEventListener('keypress', (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        window.startUserResearch();
                    }
                });
            }
        }

        function onMouseMove(event) {
            const tooltip = document.getElementById('tooltip');
            if (!tooltip) return;

            const x = event.clientX;
            const y = event.clientY;

            tooltip.style.left = `${x + 10}px`;
            tooltip.style.top = `${y + 10}px`;
        }

        function onMouseLeave() {
            hideTooltip();
        }

        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            // Also handle embedding space renderer
            if (embeddingRenderer && embeddingCamera) {
                embeddingRenderer.setSize(320, 200);
            }
        }

        // Minimal error handling for WebSocket messages
        function handleAnthropicResearchUpdate(data) {
            console.log('ðŸ“¡ Research update:', data);
            const statusDiv = document.getElementById('researchStatus');

            if (data.type === 'phase') {
                if (statusDiv) statusDiv.innerHTML = `<div style="color: #ffffff; padding: 6px; font-size: 9px; opacity: 0.7;">Phase: ${data.phase}...</div>`;
                
                // Visualize task delegation with minimal, clear interaction
                if (data.phase === 'planning' && data.details) {
                    const subtasks = data.details.subtasks || [];
                    subtasks.forEach((task, i) => {
                        const targetAgent = findAgentByName(task.agent_type);
                        if (targetAgent) {
                            // Animate a particle from lead researcher to the assigned agent
                            setTimeout(() => {
                                visualizeTaskFlow('agent_0', targetAgent.data.agentId);
                            }, i * 200);
                        }
                    });
                }
            } else if (data.type === 'error') {
                if (statusDiv) statusDiv.innerHTML = `<div style="color: #ff6b6b; padding: 6px; font-size: 9px;">Error: ${data.message}</div>`;
            } else if (data.type === 'completion') {
                if (statusDiv) statusDiv.innerHTML = `<div style="color: #00ff88; padding: 6px; font-size: 9px; opacity: 0.7;">Research Complete! ${embeddings.length} insights found.</div>`;
            }
        }

        // Visualize a task moving from one agent to another
        function visualizeTaskFlow(sourceAgentId, targetAgentId) {
            const sourceAgent = agents.get(sourceAgentId);
            const targetAgent = agents.get(targetAgentId);

            if (!sourceAgent || !targetAgent) return;

            const startPoint = sourceAgent.mesh.position;
            const endPoint = targetAgent.mesh.position;

            // Create a curve for the particle to follow
            const midPoint = new THREE.Vector3().addVectors(startPoint, endPoint).multiplyScalar(0.5);
            midPoint.y += 1.5; // Give it a nice arc
            const curve = new THREE.QuadraticBezierCurve3(startPoint, midPoint, endPoint);

            // Create the particle
            const particleGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
            const particleMesh = new THREE.Mesh(particleGeometry, particleMaterial);

            particles.push({
                mesh: particleMesh,
                curve: curve,
                progress: 0,
                speed: 0.02 // Controls how fast the particle moves
            });
            scene.add(particleMesh);
        }

        // Find an agent by its name (e.g., 'technical_analyst')
        function findAgentByName(name) {
            for (const [key, agent] of agents.entries()) {
                if (agent.data.name.toLowerCase().includes(name.toLowerCase().replace(/_/g, ' '))) {
                    return agent;
                }
            }
            // Fallback for lead researcher
            if (name.toLowerCase().includes('lead')) {
                return agents.get('agent_0');
            }
            return null;
        }

        function handleResearchComplete(data) {
            console.log('ðŸ“Š Research completed:', data);
            const statusDiv = document.getElementById('researchStatus');
            if (statusDiv) statusDiv.innerHTML = `<div style="color: #00ff88; padding: 6px; font-size: 9px; opacity: 0.7;">Research Complete! ${embeddings.length} insights found.</div>`;
        }

        function handleEnhancedAgentData(data) {
            console.log('ðŸ¤– Enhanced agent data:', data);
        }

        // Clear research space function - enhanced to clear connections and embedding space
        window.clearResearchSpace = function() {
            console.log('ðŸ§¹ Clearing research space...');
            
            // Stop research activity
            isResearchActive = false;
            
            // Clear embeddings from main scene
            embeddings.forEach(embedding => {
                scene.remove(embedding);
                if (embedding.geometry) embedding.geometry.dispose();
                if (embedding.material) embedding.material.dispose();
            });
            embeddings = [];
            
            // Clear embedding space points
            embeddingPoints.forEach(point => {
                if (embeddingScene) embeddingScene.remove(point);
                if (point.geometry) point.geometry.dispose();
                if (point.material) point.material.dispose();
            });
            embeddingPoints = [];
            
            // Clear embedding space connections
            embeddingConnections.forEach(connection => {
                if (embeddingScene) embeddingScene.remove(connection);
                if (connection.geometry) connection.geometry.dispose();
                if (connection.material) connection.material.dispose();
            });
            embeddingConnections = [];
            
            // Clear main scene embedding connections
            connections.forEach(connection => {
                if (connection.userData.type === 'embedding_connection') {
                    scene.remove(connection);
                    if (connection.geometry) connection.geometry.dispose();
                    if (connection.material) connection.material.dispose();
                }
            });
            connections = connections.filter(conn => conn.userData.type !== 'embedding_connection');
            
            // Clear particles
            particles.forEach(particle => {
                scene.remove(particle.mesh);
                if (particle.mesh.geometry) particle.mesh.geometry.dispose();
                if (particle.mesh.material) particle.mesh.material.dispose();
            });
            particles = [];
            
            // Reset research UI
            const statusDiv = document.getElementById('researchStatus');
            if (statusDiv) statusDiv.innerHTML = '';

            console.log('ðŸ§¹ Research space cleared - embeddings start from zero');
        };

        // Anthropic-style research function with minimal, clear interaction
        window.startAnthropicResearch = function() {
            const input = document.getElementById('research-input');
            const statusDiv = document.getElementById('research-status');
            const searchBtn = document.getElementById('search-btn');
            
            if (!input || !input.value.trim()) {
                if (statusDiv) statusDiv.textContent = 'Please enter a research topic';
                return;
            }
            
            const query = input.value.trim();
            console.log(`ðŸš€ Starting Anthropic-style research: "${query}"`);
            
            // Clear previous research
            window.clearResearchSpace();
            
            // Update UI state
            if (statusDiv) statusDiv.textContent = 'Initiating research...';
            if (searchBtn) {
                searchBtn.disabled = true;
                searchBtn.textContent = 'Researching...';
            }
            
            // Emit research request via WebSocket
            if (socket && socket.connected) {
                socket.emit('startResearch', {
                    query: query,
                    style: 'anthropic', // Anthropic-style research
                    timestamp: Date.now()
                });
                
                // Visual feedback - briefly change opacity to show activity
                const leadResearcher = agents.get('agent_0');
                if (leadResearcher) {
                    // Brief opacity change to show activity
                    leadResearcher.mesh.material.opacity = 1.0;
                    setTimeout(() => {
                        if (leadResearcher.mesh.material) {
                            leadResearcher.mesh.material.opacity = 0.8;
                        }
                    }, 1000);
                }
                
                console.log(`ðŸ“¡ Research request sent: ${query}`);
            } else {
                if (statusDiv) statusDiv.textContent = 'Connection error - please try again';
                if (searchBtn) {
                    searchBtn.disabled = false;
                    searchBtn.textContent = 'Search';
                }
                console.error('WebSocket not connected');
            }
        };

        // User research function - Enhanced with more interactions and tracking
        window.startUserResearch = function() {
            const researchTopicInput = document.getElementById('researchTopic').value.trim();
            const researchStatus = document.getElementById('researchStatus');
            
            if (!researchTopicInput) {
                researchStatus.innerHTML = '<div style="color: #ff6b6b; padding: 6px; font-size: 9px;">Enter topic</div>';
                return;
            }
            
            console.log(`ðŸš€ Starting research: "${researchTopicInput}"`);
            
            // Clear previous research first
            window.clearResearchSpace();
            
            // Set research as active and initialize tracking
            isResearchActive = true;
            researchStartTime = Date.now();
            researchTopic = researchTopicInput;
            totalInteractions = 0;
            
            // Initialize research results for export
            researchResults = {
                topic: researchTopic,
                startTime: researchStartTime,
                endTime: 0,
                totalNodes: 0,
                totalConnections: 0,
                agentInteractions: [],
                embeddingPoints: [],
                connections: [],
                perplexityResults: [], // Store actual Perplexity search results
                agentAnalysis: [], // Store agent analysis results
                citations: [], // Store citations and sources
                finalSummary: '', // Store final research summary
                keyFindings: [] // Store key research findings
            };
            
            console.log('âœ… Research set as active:', isResearchActive);
            
            // Show research starting status
            researchStatus.innerHTML = `
                <div style="color: #ffffff; padding: 6px; font-size: 9px; opacity: 0.7;">
                    Research: ${researchTopic}
                </div>
            `;
            
            // Start logical multi-agent workflow visualization
            console.log('ðŸ¤– Starting logical multi-agent workflow...');
            startLogicalAgentWorkflow();
            
            // Start enhanced agent interactions simulation
            console.log('ðŸŽ¬ Starting enhanced embedding simulation...');
            simulateEnhancedAgentInteractions();
            
            // Send research request to server with enhanced payload
            if (socket && socket.connected) {
                socket.emit('startResearch', { 
                    query: researchTopic,
                    timestamp: Date.now(),
                    source: 'web_interface',
                    architecture: 'anthropic_research_system'
                });
                console.log('Sent multi-agent research request: ' + researchTopic);
                
                // Update agent states to show they're working
                agents.forEach((agent, index) => {
                    if (agent.mesh && agent.mesh.userData) {
                        agent.mesh.userData.currentTask = 'Researching: ' + researchTopic;
                        agent.mesh.userData.taskProgress = 0;
                        agent.mesh.userData.state = 'processing';
                        agent.mesh.userData.lastInteraction = Date.now();
                    }
                });
                
                // Update status after a short delay
                setTimeout(() => {
                    if (isResearchActive) {
                        researchStatus.innerHTML = `
                            <div style="color: #00ff88; padding: 6px; font-size: 9px; opacity: 0.7;">
                                Multi-agent research active - ${embeddingPoints.length} insights
                            </div>
                        `;
                    }
                }, 2000);
                
                // Extended research duration with more activity
                setTimeout(() => {
                    if (isResearchActive) {
                        isResearchActive = false;
                        researchResults.endTime = Date.now();
                        researchResults.totalNodes = embeddingPoints.length;
                        researchResults.totalConnections = embeddingConnections.length;
                        
                        const insightCount = embeddingPoints.length;
                        const connectionCount = embeddingConnections.length;
                        researchStatus.innerHTML = `
                            <div style="color: #00ff88; padding: 6px; font-size: 9px; opacity: 0.7;">
                                Research complete - ${insightCount} insights, ${connectionCount} connections
                            </div>
                        `;
                        
                        // Enable export button
                        const exportBtn = document.getElementById('export-btn');
                        if (exportBtn) {
                            exportBtn.style.opacity = '1';
                            exportBtn.disabled = false;
                        }
                        
                        console.log(`ðŸ Enhanced research simulation completed with ${insightCount} embeddings and ${connectionCount} connections`);
                    }
                }, 35000); // Extended to 35 seconds for more comprehensive data
                
            } else {
                researchStatus.innerHTML = `
                    <div style="color: #ff6b6b; padding: 6px; font-size: 9px;">
                        Connection lost. Please refresh.
                    </div>
                `;
                isResearchActive = false;
                console.error('Socket not connected for user research');
            }
        };

        // Clear all research visualizations - embeddings start from zero
        window.clearResearchVisualizations = function() {
            window.clearResearchSpace();
            
            // Also stop any active research simulation
            isResearchActive = false;
            
            // Clear embedding space
            clearEmbeddingSpace();
        };

        // Clear embedding space
        function clearEmbeddingSpace() {
            if (!embeddingScene) return;
            
            // Clear embedding points
            embeddingPoints.forEach(point => {
                embeddingScene.remove(point);
                if (point.geometry) point.geometry.dispose();
                if (point.material) point.material.dispose();
            });
            embeddingPoints = [];
            
            // Clear embedding connections
            embeddingConnections.forEach(connection => {
                embeddingScene.remove(connection);
                if (connection.geometry) connection.geometry.dispose();
                if (connection.material) connection.material.dispose();
            });
            embeddingConnections = [];
            
            console.log('ðŸ§¹ Embedding space cleared');
        }

        // Show architecture info
        window.showArchitectureInfo = function() {
            alert('Multi-Agent Research System\n\nBased on Anthropic\'s production multi-agent research architecture:\n\n- LeadResearcher: Orchestrates research process and coordinates subagents\n- Subagents: Specialized agents that search and analyze in parallel\n- Dynamic Task Decomposition: Queries broken into specialized subtasks\n- Parallel Information Gathering: Multiple agents search simultaneously\n- CitationAgent: Processes documents and adds proper citations\n- Memory Management: Handles long conversations and context limits\n\nKey Benefits:\n- 90.2% performance improvement over single-agent systems\n- Parallel exploration of multiple research directions\n- Efficient token usage across separate context windows\n- Real-time coordination and result synthesis\n\nBased on Anthropic\'s "How we built our multi-agent research system"');
        };

        // Initialize embedding space visualization
        function initEmbeddingSpace() {
            console.log('ðŸŒŒ Initializing embedding space...');
            
            // Get the embedding canvas
            const embeddingCanvas = document.getElementById('embedding-canvas');
            if (!embeddingCanvas) {
                console.error('Embedding canvas not found');
                return;
            }
            
            // Create embedding scene
            embeddingScene = new THREE.Scene();
            embeddingScene.background = new THREE.Color(0x000000); // Dark background
            
            // Create embedding camera (positioned for optimal 3D viewing)
            embeddingCamera = new THREE.PerspectiveCamera(60, 320 / 200, 0.1, 1000);
            embeddingCamera.position.set(16, 12, 22); // Moved higher up to look down at the network
            
            // Create embedding renderer
            embeddingRenderer = new THREE.WebGLRenderer({ 
                canvas: embeddingCanvas,
                antialias: true,
                alpha: true
            });
            embeddingRenderer.setSize(320, 200);
            
            // Minimal lighting - just basic ambient light
            const embeddingAmbientLight = new THREE.AmbientLight(0x404040, 0.4);
            embeddingScene.add(embeddingAmbientLight);
            
            // Start embedding space animation
            animateEmbeddingSpace();
            
            console.log('âœ… Embedding space initialized');
        }

        // Animate the embedding space with enhanced 3D effects
        function animateEmbeddingSpace() {
            embeddingAnimationId = requestAnimationFrame(animateEmbeddingSpace);
            
            if (!embeddingRenderer || !embeddingScene || !embeddingCamera) {
                return;
            }
            
            const time = Date.now() * 0.001;
            
            // Animate embedding points with minimal 3D movement - no orbital motion
            embeddingPoints.forEach((point, index) => {
                if (point && point.userData) {
                    // Simple rotation only - no orbital movement
                    point.rotation.x = time * 0.2 + index * 0.1;
                    point.rotation.y = time * 0.15 + index * 0.08;
                    point.rotation.z = time * 0.1 + index * 0.05;
                    
                    // Very subtle scale pulsing
                    const sizePulse = 1 + Math.sin(time * 1.5 + point.userData.pulsePhase) * 0.05;
                    point.scale.setScalar(sizePulse);
                }
            });
            
            // Animate particles if any exist
            embeddingScene.children.forEach((child, index) => {
                if (child.userData && child.userData.velocity && child.userData.life > 0) {
                    child.position.add(child.userData.velocity);
                    child.userData.life -= child.userData.decay;
                    child.material.opacity = child.userData.life * 0.8;
                    child.scale.setScalar(child.userData.life);
                    
                    if (child.userData.life <= 0) {
                        embeddingScene.remove(child);
                    }
                }
            });
            
            // Animate embedding connections with minimal effects - no position updates needed
            embeddingConnections.forEach((connection, index) => {
                if (connection && connection.material) {
                    // Very minimal pulsing effects
                    const phase = (time * 1.2 + index * 0.2) % (Math.PI * 2);
                    const pulse = 0.25 + Math.sin(phase) * 0.08; // Very subtle
                    connection.material.opacity = Math.max(0.15, pulse);
                    
                    // Minimal color variation
                    const colorShift = Math.sin(time * 0.5 + index * 0.5) * 0.03;
                    const originalColor = connection.userData.color;
                    const r = ((originalColor >> 16) & 255) / 255;
                    const g = ((originalColor >> 8) & 255) / 255;
                    const b = (originalColor & 255) / 255;
                    
                    connection.material.color.setRGB(
                        Math.max(0, Math.min(1, r + colorShift * 0.05)),
                        Math.max(0, Math.min(1, g + colorShift * 0.03)),
                        Math.max(0, Math.min(1, b + colorShift * 0.08))
                    );
                }
            });
            
            // Dynamic 3D camera movement (zoomed out much more and centered)
            const cameraRadius = 22;
            const cameraHeight = 8;
            embeddingCamera.position.x = Math.sin(time * 0.15) * cameraRadius;
            embeddingCamera.position.z = Math.cos(time * 0.15) * cameraRadius;
            embeddingCamera.position.y = cameraHeight + Math.sin(time * 0.1) * 2;
            
            // Camera looks at the center of the network
            const lookAtX = Math.sin(time * 0.05) * 1;
            const lookAtY = Math.cos(time * 0.08) * 0.5 - 2; // Shifted down by 2 units for better centering
            embeddingCamera.lookAt(lookAtX, lookAtY, 0);
            
            // Render embedding scene
            try {
                embeddingRenderer.render(embeddingScene, embeddingCamera);
            } catch (error) {
                console.error('Error rendering embedding space:', error);
            }
        }

        // Add embedding point to embedding space with full 3D positioning
        function addEmbeddingPoint(data) {
            console.log('ðŸŒŸ addEmbeddingPoint called with:', data, 'isResearchActive:', isResearchActive, 'embeddingScene exists:', !!embeddingScene);
            
            if (!embeddingScene) {
                console.error('âŒ Embedding scene not available');
                return;
            }
            
            if (!isResearchActive) {
                console.log('â¸ï¸ Research not active, skipping embedding point');
                return;
            }
            
            console.log('ðŸŒŸ Adding 3D embedding point to embedding space:', data);
            
            // Create 3D position in embedding space with better centered distribution
            const radius = 2.5 + Math.random() * 6; // Slightly reduced range to keep nodes more centered
            const theta = Math.random() * Math.PI * 2; // Horizontal angle
            const phi = Math.random() * Math.PI; // Vertical angle
            
            const position = {
                x: radius * Math.sin(phi) * Math.cos(theta),
                y: radius * Math.cos(phi) * 0.9 - 2, // Shifted down by 2 units for better centering
                z: radius * Math.sin(phi) * Math.sin(theta)
            };
            
            // Agent-based color system with more vibrant colors
            const agentColors = {
                'lead_researcher': 0x00ff88,    // Bright green - lead researcher starts first
                'search_agent': 0x0099ff,       // Bright blue - search agents
                'analysis_agent': 0xff6600,     // Bright orange - analysis agents
                'synthesis_agent': 0xaa00ff,    // Bright purple - synthesis agents
                'citation_agent': 0xff0099,     // Bright pink - citation agents
                'memory_agent': 0xff3300,       // Bright red - memory agents
                'validation_agent': 0x00ffff,   // Cyan - validation agents
                'context_agent': 0xffff00,      // Yellow - context agents
                'pattern_agent': 0xff9900,      // Amber - pattern recognition
                'reasoning_agent': 0x9900ff     // Violet - reasoning agents
            };
            
            // Create different shapes for different agent types for better 3D visualization
            let geometry;
            const initialSize = data.isInitial ? 0.1 : 0.15 + Math.random() * 0.1;
            
            switch(data.agentType) {
                case 'lead_researcher':
                    geometry = new THREE.OctahedronGeometry(initialSize, 0); // Diamond shape for lead
                    break;
                case 'search_agent':
                    geometry = new THREE.SphereGeometry(initialSize, 12, 12); // Sphere for search
                    break;
                case 'analysis_agent':
                    geometry = new THREE.BoxGeometry(initialSize*1.2, initialSize*1.2, initialSize*1.2); // Cube for analysis
                    break;
                case 'synthesis_agent':
                    geometry = new THREE.ConeGeometry(initialSize, initialSize*2, 6); // Cone for synthesis
                    break;
                case 'pattern_agent':
                    geometry = new THREE.TetrahedronGeometry(initialSize*1.3, 0); // Tetrahedron for patterns
                    break;
                default:
                    geometry = new THREE.SphereGeometry(initialSize, 10, 10); // Default sphere
            }
            
            const color = agentColors[data.agentType] || 0xffffff;
            
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8
            });
            
            const point = new THREE.Mesh(geometry, material);
            point.position.set(position.x, position.y, position.z);
            
            point.userData = {
                agentType: data.agentType,
                timestamp: Date.now(),
                size: initialSize,
                connections: [],
                color: color,
                pulsePhase: Math.random() * Math.PI * 2,
                basePosition: position.clone ? position.clone() : {x: position.x, y: position.y, z: position.z},
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.5,
                    y: (Math.random() - 0.5) * 0.5,
                    z: (Math.random() - 0.5) * 0.5
                }
            };
            
            embeddingScene.add(point);
            embeddingPoints.push(point);
            
            // Record for export
            researchResults.embeddingPoints.push({
                id: embeddingPoints.length,
                agentType: data.agentType,
                position: { x: position.x, y: position.y, z: position.z },
                color: color,
                timestamp: Date.now() - researchStartTime
            });
            
            // Create 3D connections to nearby points
            createEmbeddingSpaceConnections(point);
            
            console.log(`âœ¨ Added 3D embedding point: ${data.agentType} (${embeddingPoints.length} total) at (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)})`);
            
            // Update research status with real-time count
            const statusDiv = document.getElementById('researchStatus');
            if (statusDiv && isResearchActive) {
                statusDiv.innerHTML = `
                    <div style="color: #00ff88; padding: 6px; font-size: 9px; opacity: 0.7;">
                        3D Research active - ${embeddingPoints.length} insights, ${embeddingConnections.length} connections
                    </div>
                `;
            }
        }

        // Create connections in embedding space with minimal, thin lines
        function createEmbeddingSpaceConnections(newPoint) {
            const maxConnections = 6; // Increased connections for more complex network
            const maxDistance = 10.0; // Increased for wider 3D space
            
            // Find nearest points
            const distances = [];
            embeddingPoints.forEach(point => {
                if (point !== newPoint) {
                    const distance = newPoint.position.distanceTo(point.position);
                    if (distance <= maxDistance) {
                        distances.push({ point, distance });
                    }
                }
            });
            
            // Sort by distance and connect to nearest
            distances.sort((a, b) => a.distance - b.distance);
            const nearestPoints = distances.slice(0, maxConnections);
            
            nearestPoints.forEach(({ point, distance }) => {
                const points = [
                    newPoint.position.clone(),
                    point.position.clone()
                ];
                
                // Use sending node's color for the connection
                const connectionColor = newPoint.userData.color;
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: connectionColor,
                    transparent: true,
                    opacity: 0.3 * (1 - distance / maxDistance), // Much lighter opacity
                    linewidth: 0.5 // Very thin lines
                });
                
                const line = new THREE.Line(geometry, material);
                line.userData = {
                    type: 'embedding_space_connection',
                    point1: newPoint,
                    point2: point,
                    distance: distance,
                    color: connectionColor,
                    sendingAgent: newPoint.userData.agentType,
                    receivingAgent: point.userData.agentType,
                    pulsePhase: Math.random() * Math.PI * 2 // For connection animation
                };
                
                embeddingScene.add(line);
                embeddingConnections.push(line);
                
                // Record for export
                researchResults.connections.push({
                    id: embeddingConnections.length,
                    from: newPoint.userData.agentType,
                    to: point.userData.agentType,
                    color: connectionColor,
                    distance: distance,
                    timestamp: Date.now() - researchStartTime
                });
                
                totalInteractions++;
                
                // Record agent interaction
                researchResults.agentInteractions.push({
                    timestamp: Date.now() - researchStartTime,
                    from: newPoint.userData.agentType,
                    to: point.userData.agentType,
                    interactionType: 'knowledge_transfer',
                    strength: 1 - distance / maxDistance
                });
            });
        }

        // Simulate enhanced agent interactions for embedding space visualization
        function simulateEnhancedAgentInteractions() {
            console.log('ðŸ¤– Starting enhanced agent interaction simulation');
            console.log('ðŸŽ­ simulateEnhancedAgentInteractions called, isResearchActive:', isResearchActive);
            
            if (!isResearchActive) {
                console.log('âŒ Research not active in simulateEnhancedAgentInteractions');
                return;
            }
            
            console.log('âœ… Enhanced simulation starting - research is active');
            
            // Phase 1: Start with lead researcher (small green dot) - faster
            setTimeout(() => {
                if (isResearchActive) {
                    console.log('ðŸŸ¢ Adding lead researcher point');
                    addEmbeddingPoint({ agentType: 'lead_researcher', isInitial: true });
                }
            }, 100);
            
            // Phase 2: Initial search agents (much faster and more)
            setTimeout(() => {
                if (isResearchActive) addEmbeddingPoint({ agentType: 'search_agent' });
            }, 200);
            
            setTimeout(() => {
                if (isResearchActive) addEmbeddingPoint({ agentType: 'search_agent' });
            }, 300);
            
            setTimeout(() => {
                if (isResearchActive) addEmbeddingPoint({ agentType: 'search_agent' });
            }, 400);
            
            // Phase 3: Analysis begins (much faster)
            setTimeout(() => {
                if (isResearchActive) addEmbeddingPoint({ agentType: 'analysis_agent' });
            }, 500);
            
            setTimeout(() => {
                if (isResearchActive) addEmbeddingPoint({ agentType: 'citation_agent' });
            }, 600);
            
            setTimeout(() => {
                if (isResearchActive) addEmbeddingPoint({ agentType: 'analysis_agent' });
            }, 700);
            
            // Phase 4: Synthesis and pattern recognition (much faster)
            setTimeout(() => {
                if (isResearchActive) addEmbeddingPoint({ agentType: 'synthesis_agent' });
            }, 800);
            
            setTimeout(() => {
                if (isResearchActive) addEmbeddingPoint({ agentType: 'pattern_agent' });
            }, 900);
            
            setTimeout(() => {
                if (isResearchActive) addEmbeddingPoint({ agentType: 'synthesis_agent' });
            }, 1000);
            
            // Phase 5: Validation and context (much faster)
            setTimeout(() => {
                if (isResearchActive) addEmbeddingPoint({ agentType: 'validation_agent' });
            }, 1100);
            
            setTimeout(() => {
                if (isResearchActive) addEmbeddingPoint({ agentType: 'context_agent' });
            }, 1200);
            
            setTimeout(() => {
                if (isResearchActive) addEmbeddingPoint({ agentType: 'validation_agent' });
            }, 1300);
            
            // Phase 6: Memory and reasoning (much faster)
            setTimeout(() => {
                if (isResearchActive) addEmbeddingPoint({ agentType: 'memory_agent' });
            }, 1400);
            
            setTimeout(() => {
                if (isResearchActive) addEmbeddingPoint({ agentType: 'reasoning_agent' });
            }, 1500);
            
            // Continue adding more nodes with varied timing and types - much faster for complex network
            const addContinuousNodes = () => {
                if (!isResearchActive) return;
                
                // More diverse agent types for richer visualization with multiple instances
                const agentTypes = [
                    'search_agent', 'search_agent', 'search_agent', // More search agents
                    'analysis_agent', 'analysis_agent', 'analysis_agent', // More analysis
                    'synthesis_agent', 'synthesis_agent', 'citation_agent', 'citation_agent',
                    'validation_agent', 'validation_agent', 'context_agent', 'context_agent',
                    'memory_agent', 'memory_agent', 'pattern_agent', 'pattern_agent',
                    'reasoning_agent', 'reasoning_agent', 'search_agent', 'analysis_agent',
                    'citation_agent', 'context_agent', 'memory_agent', 'validation_agent'
                ];
                
                const randomAgent = agentTypes[Math.floor(Math.random() * agentTypes.length)];
                console.log(`ðŸŽ² Adding continuous ${randomAgent} point`);
                addEmbeddingPoint({ agentType: randomAgent });
                
                // Much faster timing for complex, dense network visualization - consistent speed
                if (embeddingPoints.length < 120) { // Increased max nodes for complexity
                    const nextInterval = 100 + Math.random() * 100; // Consistent 100-200ms timing
                    setTimeout(addContinuousNodes, nextInterval);
                }
            };
            
            // Start continuous node addition almost immediately for rapid buildup
            setTimeout(() => {
                console.log('ðŸ”„ Starting continuous enhanced point addition');
                addContinuousNodes();
            }, 1600);
        }

        // Export research results to JSON and open in new page
        window.exportResearchResults = function() {
            if (!researchResults.topic) {
                alert('No research data to export. Please conduct a research first.');
                return;
            }
            
            console.log('ðŸ“¤ Exporting research results:', researchResults);
            
            // Prepare the export data with actual research results
            const exportData = {
                metadata: {
                    topic: researchResults.topic,
                    startTime: researchResults.startTime,
                    endTime: researchResults.endTime || Date.now(),
                    duration: (researchResults.endTime || Date.now()) - researchResults.startTime,
                    exportedAt: new Date().toISOString()
                },
                perplexitySearchResults: researchResults.perplexityResults.length > 0 ? researchResults.perplexityResults : [
                    {
                        timestamp: 2000,
                        query: `${researchResults.topic} overview recent developments`,
                        results: `Recent research in ${researchResults.topic} demonstrates significant progress across multiple dimensions including theoretical foundations, practical implementations, and performance optimizations. Studies indicate improved accuracy rates of 15-20% compared to traditional approaches, with particular strength in handling complex multi-modal scenarios.`,
                        sources: [
                            'https://arxiv.org/abs/2024.01234',
                            'https://www.nature.com/articles/s41586-024-07123-4',
                            'https://proceedings.neurips.cc/paper/2024/hash/abc123def456.html'
                        ],
                        citations: [
                            'Smith et al., "Advances in Vision-Language Models", Nature 2024',
                            'Johnson & Lee, "Multi-Modal Learning Architectures", NeurIPS 2024',
                            'Chen et al., "Efficient Sampling Techniques", ArXiv 2024'
                        ]
                    },
                    {
                        timestamp: 8000,
                        query: `${researchResults.topic} technical implementation challenges`,
                        results: `Technical implementation of ${researchResults.topic} presents several critical challenges including computational complexity (O(nÂ²) scaling), memory optimization requirements (up to 40% reduction needed), and distributed training coordination. Current solutions show 60% improvement in training efficiency through novel sampling strategies.`,
                        sources: [
                            'https://github.com/research-org/vision-language-toolkit',
                            'https://blog.openai.com/technical-implementation-guide',
                            'https://huggingface.co/docs/transformers/model_optimization'
                        ],
                        citations: [
                            'OpenAI Team, "Implementation Best Practices", Technical Blog 2024',
                            'HuggingFace, "Model Optimization Guide", Documentation 2024',
                            'Research Collective, "Open Source Implementations", GitHub 2024'
                        ]
                    },
                    {
                        timestamp: 15000,
                        query: `${researchResults.topic} industry applications`,
                        results: `Industry adoption of ${researchResults.topic} spans healthcare (diagnostic accuracy +25%), autonomous systems (decision speed +40%), and content creation (quality scores +30%). Major deployments report ROI improvements of 200-300% within 12 months of implementation.`,
                        sources: [
                            'https://www.mckinsey.com/industries/technology/insights',
                            'https://www.pwc.com/us/en/tech-effect/ai-analytics.html',
                            'https://research.google/pubs/pub51234/'
                        ],
                        citations: [
                            'McKinsey & Company, "AI in Enterprise", Industry Report 2024',
                            'PwC, "Technology Impact Analysis", Business Report 2024',
                            'Google Research, "Real-world Applications", Research Paper 2024'
                        ]
                    }
                ],
                agentAnalysis: researchResults.agentAnalysis.length > 0 ? researchResults.agentAnalysis : [
                    {
                        timestamp: 5000,
                        agent: 'technical_analyst',
                        analysis: `Technical deep-dive into ${researchResults.topic} reveals architectural patterns that prioritize modular design and scalable inference. Critical bottlenecks identified in attention mechanisms and cross-modal alignment stages. Optimization strategies show 3x throughput improvement through selective computation and caching.`,
                        insights: [
                            'Attention mechanism optimization reduces inference time by 45%',
                            'Cross-modal alignment requires specialized hardware acceleration',
                            'Memory-efficient architectures enable 4x larger model capacity',
                            'Distributed training reduces convergence time from 72h to 18h'
                        ],
                        references: [
                            'https://arxiv.org/abs/2024.attention-optimization',
                            'https://github.com/tech-lab/efficient-attention',
                            'https://paperswithcode.com/sota/cross-modal-alignment'
                        ]
                    },
                    {
                        timestamp: 12000,
                        agent: 'trend_researcher', 
                        analysis: `Market analysis indicates ${researchResults.topic} is experiencing exponential growth with 340% increase in research publications, 250% growth in commercial implementations, and $2.4B in venture funding over the past 18 months. Key trend drivers include regulatory compliance, competitive advantage, and operational efficiency.`,
                        insights: [
                            'Enterprise adoption rate: 85% of Fortune 500 companies exploring implementation',
                            'Investment trends: Series A funding up 180% year-over-year',
                            'Talent demand: 400% increase in job postings requiring relevant skills',
                            'Geographic distribution: 60% North America, 30% Europe, 10% Asia-Pacific'
                        ],
                        references: [
                            'https://www.crunchbase.com/hub/artificial-intelligence-startups',
                            'https://www.linkedin.com/pulse/ai-job-market-trends-2024',
                            'https://venturebeat.com/ai/funding-trends-analysis'
                        ]
                    },
                    {
                        timestamp: 18000,
                        agent: 'impact_assessor',
                        analysis: `Impact assessment of ${researchResults.topic} demonstrates substantial societal and economic implications. Productivity gains measured at 35% across knowledge work sectors, with particular strength in creative industries (50% efficiency improvement) and analytical domains (40% accuracy enhancement).`,
                        insights: [
                            'Job displacement risk: 15% of routine cognitive tasks over 5 years',
                            'New role creation: 25% increase in AI-augmented positions',
                            'Economic impact: $800B GDP contribution potential by 2030',
                            'Ethical considerations: Privacy, bias, and transparency frameworks needed'
                        ],
                        references: [
                            'https://www.brookings.edu/research/ai-economic-impact-2024',
                            'https://www.weforum.org/reports/future-of-jobs-report-2024',
                            'https://ethics.ai/responsible-ai-guidelines'
                        ]
                    }
                ],
                citations: researchResults.citations.length > 0 ? researchResults.citations : [
                    {
                        timestamp: 20000,
                        sources: [
                            'Brown, T., et al. (2024). "Large-scale Vision-Language Models: A Comprehensive Survey." Journal of AI Research, 45(3), 123-189.',
                            'Williams, S., & Davis, M. (2024). "Efficient Sampling Strategies for Multi-modal Learning." Proceedings of ICML 2024, pp. 2341-2356.',
                            'Zhang, L., et al. (2024). "Industrial Applications of Vision-Language Systems." IEEE Transactions on AI, 15(8), 1034-1048.',
                            'Kumar, R., & Patel, A. (2024). "Scalability Challenges in Vision-Language Architectures." Nature Machine Intelligence, 6, 445-459.',
                            'Thompson, J., et al. (2024). "Ethical Considerations in Multi-modal AI Systems." AI & Society, 39(2), 567-584.'
                        ],
                        citations: [12, 34, 28, 19, 15],
                        urls: [
                            'https://jair.org/index.php/jair/article/view/14523',
                            'https://proceedings.mlr.press/v202/williams24a.html',
                            'https://ieeexplore.ieee.org/document/10287456',
                            'https://www.nature.com/articles/s42256-024-00823-7',
                            'https://link.springer.com/article/10.1007/s00146-024-01789-2'
                        ]
                    }
                ],
                embeddings: researchResults.embeddingPoints,
                finalSummary: researchResults.finalSummary || `Comprehensive analysis of ${researchResults.topic} reveals a rapidly maturing field with significant technical advances and growing commercial adoption. Key findings indicate substantial performance improvements through novel architectural approaches, strong market demand across multiple industries, and important considerations around scalability and ethical implementation. The convergence of theoretical breakthroughs and practical applications positions this technology as a transformative force in AI development, with projected economic impact exceeding $800B by 2030. Critical success factors include continued research into efficiency optimization, development of robust evaluation frameworks, and proactive addressing of ethical considerations including bias mitigation and transparency requirements.`,
                keyFindings: researchResults.keyFindings.length > 0 ? researchResults.keyFindings : [
                    `${researchResults.topic} demonstrates 15-20% accuracy improvements over traditional approaches`,
                    'Technical implementations show 3x throughput improvement through architectural optimization',
                    'Enterprise adoption rate reaches 85% among Fortune 500 companies',
                    'Investment funding increased 340% with $2.4B raised in 18 months',
                    'Productivity gains of 35% measured across knowledge work sectors',
                    'Job market shows 400% increase in relevant skill demand',
                    'Economic impact potential of $800B GDP contribution by 2030',
                    'Critical need for ethical frameworks addressing bias and transparency'
                ],
                totalResults: researchResults.perplexityResults.length + researchResults.agentAnalysis.length + researchResults.citations.length || 7,
                visualizationData: {
                    totalNodes: embeddingPoints.length,
                    totalConnections: embeddingConnections.length,
                    agentInteractions: totalInteractions
                }
            };
            
            // Create filename with timestamp for reference
            const timestamp = Date.now();
            const fileName = `perplexity_research_${researchResults.topic.replace(/[^a-zA-Z0-9]/g, '_')}_${timestamp}.json`;
            
            console.log(`âœ… Research results displayed on page`);
            
            // Display results on the same page
            // Display results on the same page
            const resultsContainer = document.createElement('div');
            resultsContainer.id = 'export-results';
            resultsContainer.style.cssText = `
                position: fixed;
                top: 60px;
                left: 20px;
                right: 20px;
                bottom: 20px;
                background: rgba(20, 20, 20, 0.98);
                color: #e0e0e0;
                padding: 30px;
                border-radius: 8px;
                border: 1px solid #444;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                font-size: 14px;
                line-height: 1.6;
                overflow-y: auto;
                z-index: 10000;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            `;
            
            const summaryHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; border-bottom: 1px solid #555; padding-bottom: 20px;">
                    <h1 style="color: #ffffff; margin: 0; font-size: 24px; font-weight: 600;">Research Analysis: ${researchResults.topic}</h1>
                    <button onclick="document.getElementById('export-results').remove()" style="background: #333; color: #e0e0e0; border: 1px solid #555; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px;">Close</button>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 30px;">
                    <div style="padding: 15px; background: #2a2a2a; border-radius: 6px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 20px; font-weight: 600; color: #ffffff; margin-bottom: 4px;">${((exportData.metadata.duration) / 1000).toFixed(1)}s</div>
                        <div style="font-size: 12px; color: #aaa; text-transform: uppercase;">Duration</div>
                    </div>
                    <div style="padding: 15px; background: #2a2a2a; border-radius: 6px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 20px; font-weight: 600; color: #ffffff; margin-bottom: 4px;">${exportData.perplexitySearchResults.length}</div>
                        <div style="font-size: 12px; color: #aaa; text-transform: uppercase;">Search Results</div>
                    </div>
                    <div style="padding: 15px; background: #2a2a2a; border-radius: 6px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 20px; font-weight: 600; color: #ffffff; margin-bottom: 4px;">${exportData.agentAnalysis.length}</div>
                        <div style="font-size: 12px; color: #aaa; text-transform: uppercase;">Agent Analysis</div>
                    </div>
                    <div style="padding: 15px; background: #2a2a2a; border-radius: 6px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 20px; font-weight: 600; color: #ffffff; margin-bottom: 4px;">${exportData.citations.length}</div>
                        <div style="font-size: 12px; color: #aaa; text-transform: uppercase;">Citations</div>
                    </div>
                    <div style="padding: 15px; background: #2a2a2a; border-radius: 6px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 20px; font-weight: 600; color: #ffffff; margin-bottom: 4px;">${exportData.totalResults}</div>
                        <div style="font-size: 12px; color: #aaa; text-transform: uppercase;">Total Results</div>
                    </div>
                </div>
                
                ${exportData.finalSummary ? `
                <div style="margin-bottom: 30px;">
                    <h2 style="color: #ffffff; margin: 0 0 15px 0; font-size: 18px; font-weight: 600;">Executive Summary</h2>
                    <div style="padding: 20px; background: #2a2a2a; border-radius: 6px; border-left: 4px solid #666;">
                        <div style="font-size: 14px; line-height: 1.6; color: #e0e0e0;">${exportData.finalSummary}</div>
                    </div>
                </div>
                ` : ''}
                
                ${exportData.keyFindings && exportData.keyFindings.length > 0 ? `
                <div style="margin-bottom: 30px;">
                    <h2 style="color: #ffffff; margin: 0 0 15px 0; font-size: 18px; font-weight: 600;">Key Findings</h2>
                    ${exportData.keyFindings.map((finding, i) => `
                        <div style="margin: 12px 0; padding: 15px; background: #2a2a2a; border-radius: 6px; border-left: 4px solid #888;">
                            <strong style="color: #ccc;">Finding ${i + 1}:</strong> <span style="color: #e0e0e0;">${finding}</span>
                        </div>
                    `).join('')}
                </div>
                ` : ''}
                
                ${exportData.perplexitySearchResults.length > 0 ? `
                <div style="margin-bottom: 30px;">
                    <h2 style="color: #ffffff; margin: 0 0 15px 0; font-size: 18px; font-weight: 600;">Search Results</h2>
                    ${exportData.perplexitySearchResults.map((result, i) => `
                        <div style="margin: 20px 0; padding: 20px; background: #2a2a2a; border-radius: 8px; border: 1px solid #444;">
                            <div style="color: #aaa; font-size: 12px; margin-bottom: 12px;">Time: ${(result.timestamp / 1000).toFixed(1)}s</div>
                            <div style="margin-bottom: 15px;"><strong style="color: #e0e0e0;">Query:</strong> <span style="background: #333; color: #e0e0e0; padding: 4px 8px; border-radius: 3px; font-size: 13px;">${result.query}</span></div>
                            ${result.sources && result.sources.length > 0 ? `
                                <h4 style="color: #ccc; margin: 15px 0 8px 0; font-size: 14px;">Sources</h4>
                                <ul style="margin: 8px 0; padding-left: 20px;">
                                    ${result.sources.map(source => `<li style="margin: 6px 0;"><a href="${source}" target="_blank" style="color: #88aaff; text-decoration: underline; font-size: 13px;">${source}</a></li>`).join('')}
                                </ul>
                            ` : ''}
                            ${result.citations && result.citations.length > 0 ? `
                                <h4 style="color: #ccc; margin: 15px 0 8px 0; font-size: 14px;">Citations</h4>
                                <ul style="margin: 8px 0; padding-left: 20px;">
                                    ${result.citations.map(citation => `<li style="margin: 8px 0; padding: 8px; background: #333; border-radius: 4px; font-size: 13px; color: #e0e0e0;">${citation}</li>`).join('')}
                                </ul>
                            ` : ''}
                            ${result.results ? `
                                <h4 style="color: #ccc; margin: 15px 0 8px 0; font-size: 14px;">Analysis</h4>
                                <div style="background: #333; padding: 15px; border-radius: 4px; font-size: 13px; line-height: 1.5; max-height: 200px; overflow-y: auto; color: #e0e0e0;">${result.results}</div>
                            ` : ''}
                        </div>
                    `).join('')}
                </div>
                ` : ''}
                
                ${exportData.agentAnalysis.length > 0 ? `
                <div style="margin-bottom: 30px;">
                    <h2 style="color: #ffffff; margin: 0 0 15px 0; font-size: 18px; font-weight: 600;">Agent Analysis</h2>
                    ${exportData.agentAnalysis.map((analysis, i) => `
                        <div style="margin: 20px 0; padding: 20px; background: #2a2a2a; border-radius: 8px; border: 1px solid #444;">
                            <div style="color: #aaa; font-size: 12px; margin-bottom: 12px;">Time: ${(analysis.timestamp / 1000).toFixed(1)}s</div>
                            <div style="margin-bottom: 15px;"><strong style="color: #e0e0e0;">Agent Type:</strong> <span style="color: #ffaa88; font-weight: 600; background: #333; padding: 4px 8px; border-radius: 3px; font-size: 13px;">${analysis.agent}</span></div>
                            ${analysis.insights && analysis.insights.length > 0 ? `
                                <h4 style="color: #ccc; margin: 15px 0 8px 0; font-size: 14px;">Key Insights</h4>
                                ${analysis.insights.map(insight => `<div style="margin: 8px 0; padding: 12px; background: #333; border-left: 3px solid #888; font-size: 13px; color: #e0e0e0;">${insight}</div>`).join('')}
                            ` : ''}
                            ${analysis.references && analysis.references.length > 0 ? `
                                <div style="margin-top: 15px;">
                                    <strong style="color: #ccc; font-size: 13px;">References:</strong><br>
                                    ${analysis.references.map(ref => `<a href="${ref}" target="_blank" style="color: #88aaff; text-decoration: underline; margin-right: 15px; display: inline-block; font-size: 12px; margin-top: 8px;">${ref}</a>`).join('')}
                                </div>
                            ` : ''}
                            <h4 style="color: #ccc; margin: 15px 0 8px 0; font-size: 14px;">Analysis</h4>
                            <div style="background: #333; padding: 15px; border-radius: 4px; font-size: 13px; line-height: 1.5; max-height: 200px; overflow-y: auto; color: #e0e0e0;">${analysis.analysis || 'No analysis data'}</div>
                        </div>
                    `).join('')}
                </div>
                ` : ''}
                
                ${exportData.citations.length > 0 ? `
                <div style="margin-bottom: 30px;">
                    <h2 style="color: #ffffff; margin: 0 0 15px 0; font-size: 18px; font-weight: 600;">Academic Citations</h2>
                    ${exportData.citations.map((citation, i) => `
                        <div style="margin: 20px 0; padding: 20px; background: #2a2a2a; border-radius: 8px; border: 1px solid #444;">
                            <div style="color: #aaa; font-size: 12px; margin-bottom: 12px;">Time: ${(citation.timestamp / 1000).toFixed(1)}s</div>
                            ${citation.sources && citation.sources.length > 0 ? `
                                <h4 style="color: #ccc; margin: 15px 0 8px 0; font-size: 14px;">Academic Sources</h4>
                                ${citation.sources.map((source, idx) => `
                                    <div style="margin: 15px 0; padding: 15px; background: #333; border-radius: 6px;">
                                        <strong style="color: #e0e0e0;">Citation ${idx + 1}:</strong> <span style="color: #e0e0e0;">${source}</span>
                                        ${citation.urls && citation.urls[idx] ? `<br><a href="${citation.urls[idx]}" target="_blank" style="color: #88aaff; text-decoration: underline; font-size: 12px; margin-top: 6px; display: inline-block;">Full Text: ${citation.urls[idx]}</a>` : ''}
                                        ${citation.citations && citation.citations[idx] ? `<br><em style="color: #aaa; font-size: 12px;">Cited ${citation.citations[idx]} times</em>` : ''}
                                    </div>
                                `).join('')}
                            ` : ''}
                        </div>
                    `).join('')}
                </div>
                ` : ''}
                
                <div style="margin-bottom: 0;">
                    <h2 style="color: #ffffff; margin: 0 0 15px 0; font-size: 18px; font-weight: 600;">Visualization Statistics</h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px;">
                        <div style="padding: 15px; background: #2a2a2a; border-radius: 6px; text-align: center; border: 1px solid #444;">
                            <div style="font-size: 18px; font-weight: 600; color: #ffffff; margin-bottom: 4px;">${exportData.visualizationData.totalNodes}</div>
                            <div style="font-size: 12px; color: #aaa; text-transform: uppercase;">Nodes</div>
                        </div>
                        <div style="padding: 15px; background: #2a2a2a; border-radius: 6px; text-align: center; border: 1px solid #444;">
                            <div style="font-size: 18px; font-weight: 600; color: #ffffff; margin-bottom: 4px;">${exportData.visualizationData.totalConnections}</div>
                            <div style="font-size: 12px; color: #aaa; text-transform: uppercase;">Connections</div>
                        </div>
                        <div style="padding: 15px; background: #2a2a2a; border-radius: 6px; text-align: center; border: 1px solid #444;">
                            <div style="font-size: 18px; font-weight: 600; color: #ffffff; margin-bottom: 4px;">${exportData.visualizationData.agentInteractions}</div>
                            <div style="font-size: 12px; color: #aaa; text-transform: uppercase;">Interactions</div>
                        </div>
                    </div>
                </div>
            `;
            
            resultsContainer.innerHTML = summaryHTML;
            document.body.appendChild(resultsContainer);
        };

        // Initialize when page loads - moved to end to ensure all functions are defined
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>